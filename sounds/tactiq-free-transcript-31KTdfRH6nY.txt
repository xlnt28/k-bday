# tactiq.io free youtube transcript
# Building web applications in Java with Spring Boot 3 â€“ Tutorial
# https://www.youtube.com/watch/31KTdfRH6nY

00:00:00.000 Learn how to build web applications in Java with Spring Boot 3. You'll learn about
00:00:04.640 Spring's fundamentals by creating a REST API that communicates with a database and is supported by
00:00:10.880 a comprehensive suite of tests. By the end of this course, you will have learned what you need to
00:00:16.400 start building your own web applications with Spring Boot 3. Dan Vega created this course.
00:00:22.160 He is a Spring Developer Advocate, Course Creator, and Speaker.
00:00:25.920 Welcome to this course, Building Web Applications in Java with Spring Boot 3.
00:00:30.960 My name is Dan Vega. I'm a Spring Developer Advocate at Broadcom, a Java champion, and
00:00:36.400 really excited to be here with you today on this journey. So I want to start off by thanking
00:00:42.160 everyone at Free Code Camp for having me. I'm a big fan of Free Code Camp, and I'm a big fan
00:00:47.840 of the courses that are on the platform. So I'm excited to be a part of that. So today,
00:00:52.560 we're going to go on a journey together and learning the most popular Java framework around
00:00:57.840 for building applications, and that is Spring. Spring is massive. There are so many things that
00:01:03.040 you can do with it. We're going to kind of narrow it down today, but we're going to have a lot of
00:01:07.360 fun. I will go ahead and leave some links. If you want to learn more about me, danvega.dev is my
00:01:13.200 homepage. I have a YouTube channel, so if you enjoy videos around Java and Spring, you can visit me
00:01:19.840 there. Also, if you want to learn more about Spring and continue this journey, I'm an instructor
00:01:26.960 on Spring Academy, which has a bunch of free resources for learning Spring. So go ahead and
00:01:32.640 check them out there. With that, I don't have any slides. We are developers. I have a GitHub repo
00:01:39.840 with a readme in it. So if you head over to github.com slash danvega fcc for freecodecamp
00:01:47.840 dash spring dash boot dash three, I'll leave the link in the description below.
00:01:53.360 That is the repo for all the code that we're going to go today. But more importantly, the readme
00:01:58.480 that we're going to jump through right now. So there's a quick agenda on here. I don't want to
00:02:03.520 dive too far into this because we'll talk about that as we get into it. But module one, just a
00:02:08.320 quick introduction. I want to make sure you understand who I am really quickly. What are
00:02:13.680 the outcomes? What are the prerequisites for this course? What should you know? And then a real
00:02:18.720 quick intro to what is Spring? Why should you care about learning this thing? Module two is we're
00:02:25.120 going to create the project. We'll get familiar with the IDE and how to run the code and where to
00:02:30.240 put your code and how to write the code and some things like DevTools and logging. So that'll kind
00:02:36.160 of get us started, get our feet wet, get us off the ground. Module three is, hey, we're building
00:02:41.920 a REST API here today using Spring MVC. We're going to do this in memory. We're not going to
00:02:47.360 talk to a database yet. We'll kind of again walk before we can run. And we'll talk about all the
00:02:52.720 mechanics to build the REST API. From there in module four, we'll switch over our in memory
00:02:58.560 collection of things to a database. So we'll talk about all things related to setting up a database
00:03:05.360 in Spring. Module five is talking about the REST client. If you are in a Spring application and you
00:03:11.040 need to talk to another service, this is something we have to do in a lot of organizations. How do
00:03:17.040 we do it in Spring? What are the different options? How can I use them? Finally, module six is testing.
00:03:22.320 Now, I know we don't usually save tests for last, but I feel like when you're learning something new,
00:03:29.120 trying to throw in the mechanics of writing tests at the same time can be a little bit
00:03:34.000 overwhelming. So normally, I would write a particular class and then write a test for it,
00:03:40.080 kind of TDD-style, if you will. In this case, we're going to write the application, and then I'm
00:03:44.640 going to come back and talk to you about what's included in Spring for testing, which is nice.
00:03:49.920 You don't have to opt in. It's already there. And we'll talk about some of the tests that I would
00:03:53.920 have written along the way just to give you an idea of how to write tests. I'll leave you with
00:03:58.560 some resources, and that'll be the course. It's a lot of information packed into a pretty nice time,
00:04:06.400 but I think we're going to have a lot of fun with this. So quick, who am I?
00:04:09.680 I'm a husband and a father. I have two daughters, hashtag girl dad. We live outside of Cleveland,
00:04:14.640 Ohio. I am a Spring developer advocate at Broadcom, so I get to go around and talk about Spring,
00:04:21.760 but I want to make sure we understand that I have been an advocate of Spring long before
00:04:26.800 anybody was paying me to do so. This goes back years. I've been a big fan of Spring.
00:04:33.200 Spring was previously held by Pivotal and then by VMware. VMware got acquired by Broadcom,
00:04:40.320 and that's how I got to where I am now. I was recently named a Java champion, which is really,
00:04:45.840 really exciting, so I'm super proud of that. I am a Spring Academy instructor, so we have
00:04:52.160 a Academy where if you want to learn all the different things with Spring or about all the
00:04:57.600 different projects in the ecosystem, we have many instructors on there, other developer advocates,
00:05:04.080 members of the Spring engineering team. So if you want to learn more about that, head over to
00:05:09.040 Spring.academy, and I've been doing this a little while, 23 plus years of development experience
00:05:15.920 in various languages, most of which have been on the JVM, but I've been doing this a long time,
00:05:21.120 and I enjoy what I do. So if you're going to take this course, what are some prerequisites
00:05:26.800 that you should have? Well, first off, we should have some fundamentals of Java. We need to know
00:05:31.520 the Java programming language to build Java applications. I would say anywhere from beginner
00:05:37.040 to intermediate. Beginner, if you really are able to learn on your own, great. Just some fundamentals
00:05:46.240 of the Java language. So we need JDK 17 or more. Right now the current version is 21, 22 is about
00:05:54.000 to come out. 17 is the baseline for Spring Boot 3.0 apps. We're going to use the latest version,
00:06:00.320 which at the time is 3.2.3, but we need at least JDK 17 to be able to run these.
00:06:07.680 You can go ahead and check your current version with java dash dash version on the command line,
00:06:12.560 or you can check out SDKman if you're on macOS. It's a nice little utility that allows you to
00:06:19.840 install different versions of Java or other SDKs and manage them in parallel. So I can switch
00:06:26.720 between like 8 and 17 and 21, etc. Now, I am using macOS, so if you're on Windows,
00:06:34.240 I don't have the equivalent of all these, but like SDKman, you can use something like
00:06:38.640 Chocolatey to install, but some of the keyboard shortcuts will be different. I'll try and explain
00:06:44.880 those as we go. If you have questions as a Windows user, try and ask them, and I'll see if we can
00:06:50.480 answer them. So if you're a Java developer, you should have some a little bit familiar with
00:06:56.000 some build tools. So once you get past kind of the hello world in Java, you need these build tools to
00:07:02.560 to manage your application, right? Like, hey, these are the dependencies that my application
00:07:07.920 is going to have. These are the build plugins, like the steps I'm going to take to like build
00:07:12.960 an artifact that goes to production. Two of the big ones in the Java world are Maven and Gradle.
00:07:17.840 I'm going to use Maven. If you want to follow along and use Gradle, that's great too. You need
00:07:21.600 an IDE or a text editor. I'm using IntelliJ IDEA Ultimate Edition. It is a paid version. I pay
00:07:29.280 for this. I have paid for this on my own monthly. Well, now I think I pay yearly, but at the time,
00:07:34.480 it was monthly. And for the value of me of how productive I am in this tool, it wasn't a lot.
00:07:42.960 They are not sponsoring this video. This is just my personal thoughts on this.
00:07:47.440 But there is a free version of the Ultimate Edition. So the paid version, you can get a
00:07:51.840 30-day trial. If you've not done that yet, go ahead and do that. There is a Community Edition,
00:07:57.200 which you can use, which doesn't have all the features, but I'll try and point those out as we
00:08:02.960 go. You can also use something like Spring Tool Suite that is available in Visual Studio Code and
00:08:08.960 Eclipse. One thing I try to tell everyone that I talk to when I'm teaching is to use whatever tool
00:08:18.000 you're most productive in. If that is somehow notepad or a terminal with Vim, so be it.
00:08:25.200 I want you to be productive. Whatever tools you use to be productive, that's great.
00:08:30.160 This just happens to be the one that I'm most productive in, so I use that.
00:08:35.679 We'll need an API testing tool. So if you've never tested a REST API, we'll go through the mechanics
00:08:42.080 of it. But there are tools like Postman. You can do this on the command line using something like
00:08:47.920 Curl or HTTP IE, which is like Curl for humans. You can actually use it and read it and understand it.
00:08:57.120 IntelliJ Ultimate Edition has a HTTP client built in, which I'm a big fan of.
00:09:02.560 I'm going to leave you in this repo in the API folder with the Postman collection and the HTTP
00:09:09.360 client collection for IntelliJ. So whatever one you're using, you should be able to download the
00:09:14.160 collection and not have to write all these API tests yourself. Docker Desktop is not a hard
00:09:20.720 requirement. We are going to use an in-memory database until a certain point, and then we'll
00:09:25.600 swap it out for a Postgres SQL database. But we'll do so using Docker and Docker Compose,
00:09:32.720 and some of the features in Spring around Docker Compose, which are really great. I'm excited to
00:09:37.440 talk to you about those. So that's our prerequisites. What is the outcome of this course?
00:09:44.480 So a lot of people ask me, like, how can I learn Spring, Dan? Well, that's a big loaded question
00:09:50.000 because Spring can do so many things. We're going to look at that in the next section.
00:09:54.400 Spring can do so many things. So when you ask me how can I learn Spring,
00:09:58.640 boy, you better have a long time because of just the roads that you can go down.
00:10:03.600 But if we narrow down this road and we get a little bit more laser focused and you ask me,
00:10:10.160 hey, Dan, how can I learn Spring to write a REST API that talks to a database?
00:10:18.160 Now we have a much more focused learning path, and that's what we're going to do today. We're
00:10:22.720 building a REST API. It talks to a database. I'm going to teach you some of the mechanics
00:10:27.440 around that, some of the things that I've learned over the years, some best practices.
00:10:31.840 We'll write some tests as we saw. And yeah, we're just going to learn a whole bunch of those things.
00:10:36.320 So what is Spring? What can it do? What can it do? We'll talk about that in a second.
00:10:41.840 How to build a web application, how to test it, how to interact with the database.
00:10:46.400 What are we going to build? We're building a fitness application that allows you to track
00:10:50.160 runs through a REST API. That's not the important part. The important part here is to take what
00:10:56.880 you've learned and apply it to your own project. After you're done with this course, you really
00:11:02.080 need to go through the mechanics of doing it yourself and not relying on me being able to
00:11:07.600 tell you what to do. So take this and apply it to whatever you're interested in. If you like cooking,
00:11:12.880 create a recipe REST API. If you like lifting weights, go ahead and create an application like
00:11:19.440 that. So whatever you're interested in, try to apply this after we're done here. And then I think
00:11:25.360 that will kind of really help cement some of the things we're going to go through. What and why
00:11:29.920 is Spring? So I'm going to click on this link. It's going to take me over to spring.io. This is
00:11:34.720 the main website for Spring. We'll get into why in a second. So what can Spring do? Spring allows
00:11:41.760 you to build so many different types of applications. Do you want to build micro services? So you have
00:11:47.200 a bunch of services in an organization that kind of talk to each other. There are some really great
00:11:52.240 benefits to building microservices, big buzzword these days, right? Independently scalable. So if
00:11:58.400 we have one application that just needs to scale more than others, microservices are great.
00:12:04.240 You can build reactive applications, so non-blocking applications. So we know in kind of
00:12:09.520 the Java world where we have this thread per request, we want to be able to not block our
00:12:15.200 applications. We want to be able to scale better. That is the case with reactive web applications.
00:12:20.560 But JDK 21 just came out. There are these things called virtual threads. So if you're in a blocking
00:12:27.760 style application, there are ways to kind of scale those applications now as well. Cloud is big. We
00:12:34.240 talk about, and actually I wonder if we go into Spring Cloud. There's a video that we recently
00:12:40.000 did, and I'm going to just jump there now. So if you go into projects and you go look at all the
00:12:44.720 different projects in the ecosystem, here's Spring Cloud. There's actually some videos on here. We
00:12:50.320 did a Spring Office Hours video. So this is a podcast that me and my co-worker, Deshaun, run.
00:12:56.960 And we did a video where we kind of talked about all the different projects in Spring Cloud at a
00:13:01.520 high level and what they do. And this was really fun because we talked about Spring Cloud as basically
00:13:08.000 the tool to build distributed applications in the cloud. And when you're doing this, a lot of
00:13:14.560 common patterns are going to come up that you're going to need to
00:13:18.160 handle. And Spring Cloud gives you the tools for doing that. So that's Spring Cloud web apps.
00:13:24.240 That's what we're going to focus on today, building an MVC application that talks to a database.
00:13:28.960 You can also use Spring for building serverless applications. Hey, I want a function to sit on
00:13:34.560 AWS Lambda service. And when I send it a request, it will spin up, handle that request,
00:13:40.800 do what it needs to do, and then shut down. We can work with event-driven applications. We can
00:13:46.480 work with batch applications. So much more. Another thing that I don't see listed on here
00:13:51.840 that I've been using Spring for a lot more lately is building CLI apps. So if you want to build a
00:13:58.080 CLI, you might think, well, I would reach for something like Bash, Dan. And that's great,
00:14:02.880 but I don't use Bash every day. So I forget how to even do the simplest of things. So I would be
00:14:09.120 running over to chat GPT and asking chat GPT, how do I do a for loop in Bash? So with Spring CLI,
00:14:16.960 I can build those interactive command line applications using the tools that I'm familiar
00:14:22.480 with. That's a little bit of what can Spring do. If you go into Y, here's some great information on
00:14:27.920 it. Again, it's the world's most popular Java framework. Here's a really good quote from
00:14:34.480 Bix, Sporting Goods. So we use a lot of the tools that come with Spring Framework and reap the benefits
00:14:40.640 of having a lot of the out-of-the-box solutions and not having to worry about writing a ton of
00:14:46.640 additional code. So again, we're starting with a web app, but what if you need to talk to a database?
00:14:51.600 What if you need to build for the cloud? What if you need to build reactive web applications?
00:14:57.600 All of those tools are in the ecosystem here. All of those projects are here for you,
00:15:02.000 and they all integrate seamlessly, which is really great. So Spring is everywhere, flexible,
00:15:06.880 productive, fast, secure, supportive. Again, what can Spring do? I think there was another quote on,
00:15:14.720 yeah, this is a good one. So if you don't know, Netflix is a huge Spring user, and it says,
00:15:20.560 most of our services today are based on Spring Boot. I think the most important thing that Spring
00:15:25.200 has just been very well-maintained over the years. That is important for us in the long term because
00:15:30.800 we don't want to be switching frameworks every two years. So Spring has a huge engineering team.
00:15:38.400 We have releases on the Spring Framework side every year. On Spring Boot, we have releases
00:15:43.920 every six months. And yeah, I think that's an important piece. So thanks, Paul, for that quote.
00:15:50.480 So you can go into why, learn about that here. You can go into learn. You can learn like an
00:15:55.680 overview, how to get started quickly, but we're going to do that today. There are some really
00:16:00.400 good guides. These are kind of quick 15-minute to 30-minute, how do I do this one specific thing?
00:16:06.960 So those are great, but I'm going to show you those on Spring Academy in a second.
00:16:11.040 There's a blog, so get caught up, stay caught up with what's going on in the ecosystem.
00:16:16.960 And actually, I think if I go to overview, yeah, so here's the latest videos. Our Spring Office
00:16:22.400 Hours is one of the latest videos on here. Josh Long, who's a legend in our community,
00:16:28.480 has a podcast on Spring. You can go ahead and check that out. Here are some popular guides.
00:16:34.080 Projects we'll come back to in a second. I mentioned the Spring Academy. If you go over
00:16:38.720 to Spring Academy, you'll see that there are some courses there. We also have these guides. These
00:16:44.320 are the same guides that are in Spring I.O., but not all have been ported to the Spring Academy yet.
00:16:50.000 The nice thing about these is that you can do this in the browser. So this thing, I want to build an
00:16:56.640 application with Spring Boot. You go through and there's an integrated lab environment where you
00:17:00.880 can walk through and do this yourself here. So really exciting. Check out Spring Academy for that.
00:17:08.079 Then we have solutions. So if you want to get support at a commercial level,
00:17:13.040 check out the Tanzu Spring runtime. We have some community and even that all important dark mode.
00:17:20.640 So quickly, we're going to go into projects. We're going to click on the overview. These are all the
00:17:24.319 different projects in the ecosystem. So when you go into a project, you'll be given an overview.
00:17:30.960 You'll be given a learn section. This is where all the documentation is. So here's the reference
00:17:36.000 docs. Here are the API docs. If you want to get at the APIs, that's important. And just as important,
00:17:42.720 the support timelines. What is the open source support? What is the commercial support timelines?
00:17:49.600 So I'm going to go to Spring Boot. We're going to be going through Spring Boot today.
00:17:53.360 If you go into the learn section and you go into the reference docs, here is like, hey,
00:17:58.000 how do I get started with Spring Boot? So I can go in and click into a section, get started.
00:18:03.840 These are some of the things we've talked about before. But just documentation is really great.
00:18:10.160 One of the things about Spring that you have to know is that it's been around forever, right?
00:18:15.040 We just celebrated 20 years of Spring, 10 years of Spring Boot. This is really great,
00:18:21.040 but it also means that if you go out there and search for a question on Google,
00:18:25.360 you might get 10 different answers. And how do you know which one is up to date?
00:18:30.080 Which one is the right one? So I suggest first line of defense is always starting at the
00:18:36.480 documentation because this is constantly being updated. This is being managed by the Spring
00:18:41.840 team. This is a really good place to start. All right. And then there's some resources here.
00:18:46.160 I'm going to update this. The reason I wanted to do this in a README is so we can constantly
00:18:50.240 update this and help you out. I'll put some notes in here. If I see issues come up,
00:18:55.040 we can go ahead and add those to this repo. This is kind of our home for everything that
00:19:00.240 we're doing today. So that was our intro. We're calling that module one. Module two is going to
00:19:06.800 be getting started, creating your first project, writing your first code in Spring. And I think
00:19:12.640 we'll go ahead and do that now. So I really hope you enjoy this course. I think we're going to have
00:19:18.080 a lot of fun on this journey and I'm excited about it and I hope you learn a lot. So with that,
00:19:23.520 let's go ahead and head to module two. All right. So the best way to kick off a new Spring Boot
00:19:29.440 project is by using the Spring initializer at start.spring.io. So I'm going to go through a
00:19:35.040 couple options here. We're going to create our first project and then we'll go ahead and write
00:19:39.360 some code. So we start off with what is the project type? This is what is the build tool. So
00:19:45.200 I mentioned in the prerequisites that it'd be nice to know if you had some experience with
00:19:50.240 Java build tools like Maven or Gradle. And this is where those come into play because you need to
00:19:56.160 pick a project type. I'm going to choose Maven. If you want to choose Gradle and you've used that
00:20:00.320 before, there is nothing wrong with that as well. In fact, it's the default. So language,
00:20:06.800 I'm going to pick Java. You can also use Kotlin or Groovy. And then we need to pick the version
00:20:12.240 of Spring Boot that we're going to use. I recommend using the latest stable version,
00:20:16.880 which at the time of this recording is 3.2.3. You can always upgrade this in your application,
00:20:22.640 so don't worry about it. Just pick the latest stable if you want. So now you're going to fill
00:20:27.200 in some data about your project. And the way this works is you have a group and an artifact
00:20:32.880 and you usually use the reverse domain. So my personal website is danvega.dev. So I'll use
00:20:39.680 the reverse of that, which is dev.danvega. And then the artifact is what are we building here
00:20:45.600 today? What is the application called? So in this case, it's called runners. And we'll go ahead and
00:20:51.360 use that name. You could fill in a description, a package name, anything else is fine. Now you got
00:20:57.680 to pick a version of Java. So we talked about at the beginning to use Spring Boot 3. You need at
00:21:03.200 least Java 17. I'm going to pick Java 21, but I don't think you need to. So if you're on Java 17,
00:21:10.960 that's fine. Now we get to the point where we pick our dependencies. So what are dependencies?
00:21:17.440 So when we're building out bigger or larger applications, enterprise type applications,
00:21:23.680 they're usually made up of a bunch of different projects, right? It's not just like Java code.
00:21:30.560 There is, hey, I need to like, use this project and use that project and use these two projects.
00:21:35.920 And that's how you kind of build these larger style applications. In the world of Spring,
00:21:41.120 Spring has a bunch of different projects in the ecosystem. And it will allow you to kind of
00:21:45.840 construct your application. I liken this to going to the grocery store, having an idea of mine in
00:21:52.800 mind of what you're going to cook tonight, right? If I'm going to make a steak and potatoes and a
00:21:58.560 glass of wine, like I understand the ingredients that I need to get as I'm going into the store.
00:22:04.880 So as we're coming here to the start.spring.io, I need to have an understanding of what I'm trying
00:22:09.600 to build today. Remember, Spring does all of these different things. It can build all these different
00:22:14.880 types of applications. So I need to have an idea of what I'm trying to build here today. And we do.
00:22:20.480 We're building a web API today. So we're building a Spring MVC app that talks to a database.
00:22:28.000 Now, the nice thing is these dependencies are just kind of quick starters, like it encapsulates
00:22:32.320 all the functionality of, say, building a web app. But you don't need to know everything you're going
00:22:37.440 to do today. For instance, we're going to talk to a database at some point, but I'm not going to pick
00:22:41.520 the data stuff yet because we're not there yet. So when I go into dependencies, I'm going to search
00:22:46.240 for web, and I'm going to choose that. The other one I'm going to choose is the Spring Boot dev
00:22:51.760 tools. And this is some really nice features for development mode. So we're going to choose those.
00:22:58.560 And that's all we need. From there, I want to show you just a quick, a quick couple of things.
00:23:03.840 You can go to explore and see what code it's going to create for you. Again, this is more of a
00:23:09.280 bootstrapping your application. This isn't generating code based on what you're selecting there.
00:23:16.320 So there's that. Then there's a share button. If you want to go ahead and copy this,
00:23:21.040 you can send this to someone else, and it will pre-populate the spring initializer for them
00:23:25.600 here, which is really nice. So with that, you're going to go ahead and click generate.
00:23:30.720 You're going to generate that. It is going to download a zip file. You're going to open that
00:23:36.400 up in whatever text editor or ID you're using. Again, as we talked about at the beginning,
00:23:42.320 I'm going to use IntelliJ Ultimate Edition. You can use IntelliJ's Community Edition.
00:23:47.840 You can use Visual Studio Code. You can use Spring Tools Suite with Eclipse.
00:23:53.520 There are a whole bunch of different options here. But if you haven't downloaded a version
00:23:58.640 of IntelliJ yet, there's a 30-day free trial for the Ultimate Edition. So I would go ahead and do
00:24:03.520 that. But either way, let's try and follow along. If you have some questions or you're stuck on this
00:24:09.280 part on how to open a Maven project in a particular text editor or ID, let me know in the comments,
00:24:15.280 and we'll see if we can answer that. So with that, I'm going to open this in IntelliJ,
00:24:19.280 and we are going to take a tour of that and write some code. All right. So we've opened the
00:24:25.120 application here up in IntelliJ. I'm just going to take a quick tour around. One of the things I
00:24:30.640 like to do, I just like to rename this to application. I don't like these long main
00:24:35.280 application class names, but you don't have to do that if you're not weird like me.
00:24:40.080 So this is like a normal Maven project structure. So we have our source main Java. This package
00:24:47.600 contains all our Java codes. So we have our main package here, which was created based on all that
00:24:52.720 metadata we filled out at the beginning in the Spring Initializer. And then we have our main
00:24:57.600 application class. We'll come back to this in a second. We have resources. This is where we're
00:25:02.960 going to have like static files or templates if we're building out like a UI. There's also our
00:25:09.440 properties files. You'll also see maybe an application.yaml in here. That's also for
00:25:14.320 configuration. So that's our resources. Then we'll have a test package. And under test,
00:25:21.440 we'll have Java. And then we'll have a package mirroring our package structure in our application
00:25:26.800 class. So we are in here. And then we have this dot Maven dot Maven Maven command. And these are
00:25:34.800 the Maven wrapper. So this means that you don't have to have Maven installed on your machine to
00:25:39.520 be able to run this application. There's kind of a wrapper included in the project. And this is nice
00:25:45.280 because if somebody else downloads your project, they don't need to have Maven installed. It makes
00:25:49.760 everything so much easier. The palm that XML is where all of our dependencies are declared. So
00:25:56.080 this is the Maven build tool. It has dependencies. It has build plugins for things that we might need
00:26:02.080 to do. Again, these are the things that we picked at the beginning. So if you wanted to kind of drill
00:26:07.840 into these, these are what's known as Spring Boot starters. This starter includes a bunch of other
00:26:13.680 dependencies. And it's an easy way to get up and running without having to figure out all of the
00:26:18.800 things that your application needs. You can command click on a Mac, control click on Windows,
00:26:24.800 I think, to look at the other dependencies in there. So all of that is kind of the basic project
00:26:31.120 structure that we get right out of the box. All right. So the main application class here
00:26:36.960 is the it contains the main method. So, you know, in Java, every Java program needs a main method.
00:26:43.360 Public static void main takes an array of strings called args. And then in here, it is using the
00:26:52.240 spring application dot run method, passing in the class name with the args. And this is how the main
00:27:00.240 application runs. So now that we know that let's figure out how to run the application. So we can
00:27:06.560 run the application a couple of different ways here in the IDE. So we have these play buttons,
00:27:13.840 so you can run the actual class, you can run the actual method, you can come up here and hit the
00:27:19.200 run button. So I'm going to just do it here. And we're going to go ahead and click run. You'll see
00:27:24.560 some things going on in here. One of which is, hey, the port that you're trying to run on is already
00:27:30.800 in use. So you may have that if you have like other applications running. No big deal. Let's just go
00:27:37.840 ahead and take care of that right away. So one thing you can do is use this tool called jps
00:27:43.520 and see which ones are running on which port. In this case, I know that I need to kill this
00:27:50.000 particular one. So 9 2 4 6 4 9 2 4 6 4 4 6 4 Dan. And now we should be able to go ahead and run our
00:28:01.120 application. And everything's running. We'll come back to like what some of this console logging is
00:28:07.200 in a second. But I'm just going to stop it there. So that's one way to run it. Another way is by
00:28:12.240 using Maven. So we said that there's the Maven wrapper included. And we can actually run this
00:28:17.840 from a command line. I'm using the terminal integrated in my ID. You could use whatever
00:28:23.280 terminal you use. Pop open that and go ahead and run this using Maven. So I'm going to say Maven.
00:28:29.440 So so look at this. So we have dot mvn. We have dot mvnw. So mvnw. And now I need to give it a
00:28:38.720 command. Now what commands are available to me? So in IntelliJ, there is this nice little Maven
00:28:44.880 plugin or window that will kind of show you what is available. And if you look in plugins,
00:28:50.240 hey, there's these things. What about Spring Boot plugin? Well, Spring Boot has a bunch of
00:28:54.960 commands, one of which is spring dash boot colon run. So we know that's one thing that we can do
00:29:00.560 to run the application, we can say spring dash boot colon run, and then it will run the application
00:29:06.880 does pretty much the same thing that our play button here does in the IDE. So I tend to go that
00:29:13.600 way. If you need to stop this, you need to control see that. And then I'm just going to close this
00:29:17.920 out. I will continue to run it this way, but just wanted to give you that option because that's how
00:29:23.120 it's typically run on the server, right? There is no IDE, there's no play button on a server,
00:29:28.800 it's run through that Maven W command. So that's how we can start our application.
00:29:35.520 Let's take a look at creating some code. The nice thing about Spring Boot is that it doesn't really
00:29:42.560 put any restrictions on you on where you kind of create code. That's a nice thing. For me,
00:29:48.240 that's also a con. I like to be told where things should go, because if you're not, sometimes you
00:29:54.240 can kind of shoot yourself in the foot, right? So let's take a look at some examples here of where
00:30:00.880 you could put code and where you can not put code. So this is the default package, this dev.danvega.runners.
00:30:10.080 I could easily come in here and create a new package and maybe call this food.bar. And inside
00:30:17.760 of here, put some kind of class. Let's just put a class that is called the welcome message, right?
00:30:25.360 So inside the welcome message, I will create a constructor. Actually, let's just create a
00:30:32.560 method. So we'll say, hey, I want to return a string. We'll call this get welcome message.
00:30:38.560 Welcome to the Spring Boot application. And if you look in the bottom left, I have like tool tips
00:30:44.640 to show you like some of the keyboard shortcuts I'm using. You'll also notice that I'm getting
00:30:49.600 some assistance on code. That is through copilot. It's a great little tool. So if you notice that,
00:30:56.160 it'll just kind of help us speed things up a little. So I have this get welcome message. I
00:31:01.760 have this welcome message thing. I'm going to mark this with an annotation. We'll talk about more
00:31:08.240 about annotations as we go. But essentially, what this should mean is that this class is available
00:31:15.520 to Spring. So in theory, that's what it should mean. Now, if I go into my application and I say
00:31:24.000 var welcome message is equal to new welcome message, I could do that, right? And then I could say
00:31:32.640 welcome message dot what is the what did we say dot get welcome message dot s out. And we'll just
00:31:40.000 print that and we'll go ahead and run this. So in this instance, let's take a look down here.
00:31:49.600 Let's actually make this a little bit smaller because it's in the way.
00:31:53.280 So we have our message printing down here. You'll see it in a second. It says welcome to
00:31:56.960 Spring Boot application. So this this is fine when we are controlling the instance of the class. But
00:32:03.840 as we will see throughout this course, we are Spring is an inversion of control framework,
00:32:09.920 meaning we kind of flip the onus on the framework to handle all of these instances for us. Anytime
00:32:15.920 you see new, we probably shouldn't be doing this. This is a place where Spring can handle these
00:32:20.960 things for us. So what I want to do is ask Spring for that particular welcome message and see if
00:32:30.720 we can use it. In this case, it's not going to work because we've made it outside of the default
00:32:36.400 class. So so we're in outside of that main class. You can also put this in a default package. So
00:32:45.280 let's do that. Continue and let's move this. So this is what's known as the default package,
00:32:52.880 where there is just no package, right, because it's in the source main Java where there's no
00:33:00.240 package declaration. So this is also going to exploit this issue. So now what I'm going to do
00:33:07.200 is I want to go ahead and just get all of I'm going to try to get an instance of that welcome
00:33:13.680 message class. Again, not to overload you right away. We'll talk more about this. There is this
00:33:19.440 huge container of all the classes in your application called the application context,
00:33:24.720 and we can ask the application context for a particular class, in this case, the welcome
00:33:30.000 message. So I want to try and do that here. So what I can do is say, hey, this is the context
00:33:36.720 and hey, context, I want to go ahead and get a particular bean and we'll get it by its name,
00:33:42.560 which in this case should be welcome message. And we'll create a variable of that. So this
00:33:49.360 just kind of shortcuts in IntelliJ to kind of create this. So I'm going to say welcome
00:33:58.000 message, right? And that should work. But what's going on here? It's saying, hey, I don't know what
00:34:07.200 that is. What is welcome message? I don't see that. And in fact, even if I was going to make
00:34:12.800 this an object and try and get this out of here, let's just sis out welcome message. Let's go ahead
00:34:19.679 and try and run this. It's going to say, hey, I don't know what you're doing. I don't have a
00:34:27.120 particular bean called the welcome message. Now, bean is one of those terms that like scares people.
00:34:34.159 I know it's like, what is that? What's a bean? A bean is nothing more than an instance of a
00:34:39.280 class with some metadata around it. So just think, hey, when you see the word bean, this is an
00:34:43.840 instance of a class that the spring container, this huge application context is container of
00:34:49.679 objects is managing for me. So all it's saying is, I don't know what this welcome message is that
00:34:55.040 you want to do, that you want to access. This is because we are outside of the main package. So
00:35:02.000 my first tip here with writing code is make sure it is within the main package. So if we move this
00:35:09.040 welcome message into here, and now we go back to here and we say welcome message. Welcome message
00:35:15.360 is equal to context dot get bean. And what we can do is just say, let's cast that to a welcome
00:35:26.480 message and then get this out. And then we'll go ahead and rerun this. And now we should go
00:35:32.880 ahead and print that out again. And we actually just print out the we don't have a two string in
00:35:37.280 this class. So we print it out. So that was just a long way of saying, hey, don't put code outside
00:35:43.120 this main package or in the default package. Because when we get into using springs dependency
00:35:49.440 injection and version of control, it's not going to work. All right. So you don't need to ever do
00:35:55.680 this. This was just for kind of demonstration purposes there. Let's go ahead and rerun the
00:36:02.080 application. And everything is working. So we have this log, we have this console here of things
00:36:09.120 going on. And let's just talk about some things that are going on in here. So first off, there's
00:36:13.200 this banner. So it's saying, hey, spring is a spring boot. This is the version of spring boot
00:36:17.840 that you're using. And then there's some default logging going on. So the nice thing is you don't
00:36:22.960 have to configure logging out of the box. This is already done for you. If you were to start a
00:36:27.280 new Java project, a new Maven project, you'd have to like figure out how to get logging up and
00:36:32.560 running, this is already working for you. And so there's a bunch of things the framework is going
00:36:37.680 to log for you. And then you can add your own logging if you need to. So let's try that real
00:36:43.280 quick. So in any class, you can go ahead and add a logger, I have a little keyboard shortcut for
00:36:51.760 this. But all we're doing is saying private, private static final logger log. And again,
00:36:57.600 if we look at our imports, we can see that this is coming from slf4j. That is the default logger
00:37:04.880 in spring boot. And we can say log factory that get log, get logger for this particular class.
00:37:12.320 Again, this is something I create a shortcut for this is something I don't want to type out. So
00:37:16.800 whatever ID or text editor you're using, I suggest maybe creating a shortcut for that.
00:37:22.800 Now that I have a logger, I can say log dot info. And I could say our application has started
00:37:29.280 successfully. Now when I go ahead and log this, I can see that this is there. Now I have a log
00:37:36.400 message saying that this started successfully. Now if you you shouldn't be brand new to the
00:37:41.840 Java world, so we should understand that there are some different levels of logging, like debug,
00:37:47.440 warn, error, etc, trace, etc. And we can kind of change those logging levels. What do we want to
00:37:54.640 see in the logging? So go ahead and check out the documentation to dive a little bit more into that.
00:38:01.600 So what we see here is that we have no active profile. We'll talk more about those later. We
00:38:08.560 have our dev tools set. So we have dev tools enabled, which is good. What does dev tools do
00:38:17.360 for us? So dev tools does if we go ahead and do this, when we hit save, it should automatically
00:38:24.560 restart the application for us. So that way I don't have to constantly like make code changes
00:38:30.400 and restart something. Now you'll notice it didn't change. And that's okay, depending on what text
00:38:35.360 header ID you're using, it might be automatic. It might be something that you have to change.
00:38:41.040 So if I come in here and I go to build and I go into build tools, Maven, we are looking for the
00:38:50.240 compiler build project automatically. So I want to say, hey, go ahead and build this automatically.
00:38:56.640 So I'm going to just add this log.info in here and something changed. And let's go ahead and click
00:39:04.720 save and see if that changes it. And what we're looking for is that automatic restart. So you can
00:39:11.600 see it restarted, something changed. And now I could just close this and constantly work on my
00:39:18.000 application. Now it's only going to restart when we change our code. Like the something that's
00:39:24.240 happening behind the scenes is not going to restart this. So this is nice because I don't have to
00:39:28.880 remember to always restart my application. The other thing dev tools does is it sets a lot of
00:39:34.000 sensible defaults. So we don't have any examples of this right now, but later on when we use
00:39:40.640 something like an in-memory H2 database, when you're using this in development mode, you probably
00:39:46.880 want the H2 console enabled. This is a UI that can go in and see your database tables and columns
00:39:54.320 and rows and et cetera. And so in development mode, of course I want this on. I don't want
00:39:59.120 to have to go like enable this. It automatically enables it for us. So that's dev tools and that's
00:40:06.160 logging. Let's go ahead and start to write our application out. Let me go ahead and clear some
00:40:12.080 of those imports. I'm going to save this. And I want to start to write our application. Now,
00:40:19.040 what we're going to be building here today is just a simple fitness application to track
00:40:24.320 runs. I like to go out and run. So I want to track different runs that I'm doing.
00:40:29.280 And it's not that exciting, but the important part here is I put this in the documentation as well
00:40:34.880 is I want you to go through this today, learn the kind of mechanics of building this application out,
00:40:41.040 and then take this and apply it to something in your life. If you like to cook,
00:40:45.600 make a recipe application. If you like to lift weights, make a lifting application. If you like
00:40:51.600 to go out and whatever it is, try to apply this to whatever you're doing in your life.
00:41:01.200 So again, one of the things I love about Spring Boot is it's going to allow us to create code
00:41:07.520 anywhere. But this is also a problem. We can kind of structure code however we want.
00:41:12.240 There's two kind of popular ways to structure code. There's more, but let's just start with
00:41:17.440 these two. There's two ways to kind of structure code. You could come in here and say,
00:41:22.320 I'm going to package by layer and what are layers? So in an MVC app, you might have things like a
00:41:29.760 controller, a model, a service, config, repository, etc. There are all these different kind of layers
00:41:41.360 of the application. Some people, and I did this forever as well, may structure their application
00:41:49.040 this way. The problem with this is I know where all my controllers are, so I have a run controller,
00:41:54.720 user controller, type controller, whatever it is. I know where all the controllers are,
00:41:59.840 but the controllers, when you're in this controller package, will always have to talk to something
00:42:04.880 outside of this package. A run controller would have to talk to a run service, so both of these
00:42:10.400 things need to be public. So one of the things that I like to do is use a technique, an architecture,
00:42:17.360 called package by feature. So I'm going to come in here and say run. Run is the feature. Later on,
00:42:24.080 we're going to be doing something with users to be able to work with the REST client. So I may
00:42:29.760 have a package called user. So now I know that everything revolving around a run is in this
00:42:36.560 particular package. I can find everything quickly. Everything is in the same package. It can live
00:42:42.160 in the Java world of, hey, everything by default is packaged private, so everything can kind of talk
00:42:48.160 to each other in this package. So we're going to model our application after a run. So I'm going
00:42:56.720 to come in here. I'm going to create a new Java class, and I'm going to call this run. So right
00:43:02.000 away, I'm going to just tell you that I'm doing this the verbose way first, the long way, just to
00:43:07.600 kind of show off some features of Java if you're not used to it. So what I'm going to do is, hey,
00:43:13.840 what are all the fields that this particular class needs to know about? Wow, co-pilots on its game
00:43:20.560 today. Look at this. Okay, so ID title started on completed on miles and location. Yes. And look at
00:43:28.080 all this code that it needs to generate. It needs to generate all of these fields. So these are
00:43:34.800 private fields, a public constructor that sets all of these things, and then has getters for each of
00:43:42.800 these. So most of the time, you have getters and setters, right? So I might come in here and I might
00:43:49.600 say, generate my getters and setters. Let's do that for all of them. I might have a equals and
00:44:00.000 hash code. So I might do that for all of those. And then I might have a two string. So I have a
00:44:07.440 two string, and all of that. And now we have 100 lines of code, just to represent a simple run in
00:44:16.400 our system. Of course, if you're a Java developer, you know where I'm going with this, but we can get
00:44:21.360 rid of all of this. And in fact, I'm going to go ahead and just delete this. And I'm going to go
00:44:27.760 ahead and say, let's create a new Java class called run. And this is going to be a record.
00:44:34.880 So now a record has record components. So something like an integer ID, string title,
00:44:42.240 let's see, I'm going to put these on different lines. And we have an integer ID, string title,
00:44:50.160 string started on. Actually, I want to do this as a local date time. And we'll do that for this.
00:44:57.600 So this is a local date time. And then we have a location, which I'm actually going to create
00:45:04.000 an enum from. So let's create, why is that? Oh, that's why. So let's do that.
00:45:22.640 All right, now we should be able to. Let's not let me create that. Let's just go ahead and create
00:45:37.760 a Java class called location. And this is going to be an enum. So it has a specific set of values
00:45:44.160 that we can pick from. In this case, I'm going to say indoor or outdoor. That's all I need to know.
00:45:49.040 Is it an indoor run or is it an outdoor run? So great. So that is a record. Look at all that code
00:45:56.560 we got rid of. We're down to 12 lines of code. And I could put this on one line of code. I just
00:46:00.640 think this is more readable. And we have this nice run record that we can go ahead and create
00:46:06.960 instances of runs with. So let's actually do that. Let's I say we go ahead and create a simple run
00:46:15.200 in the system just to kind of test this out. So one place I can do this is in the application
00:46:22.560 class. I'm going to go ahead and delete that. So I'm going to create something called a command
00:46:28.800 line runner here. Don't worry about it. We'll we'll get into this as we go throughout the course.
00:46:34.080 But a command line runner is just something that runs after the application has started.
00:46:38.800 And more importantly, after the application context has been created, this container
00:46:43.920 of all the beans in the system. Right. So what I can do is I can say something like this. And that
00:46:51.760 would get run after the application has started. I just want a simple way to test my run. So I'm
00:46:57.280 going to say run run is equal to new run. And we need to pass in an ID. Let's see if this is good.
00:47:05.760 So title started on. So we are not going to use the string version of this we can
00:47:20.160 actually let's just simplify this. So this is a local daytime. I don't know why I'm letting
00:47:26.320 co pilot do all this. Let's do this without co pilot. So I'm going to say local date time.
00:47:33.600 That now that's going to be my started on. I'm going to say local date time now plus now I can
00:47:43.440 add some amount. So I'm going to say one. And then what is the temporal unit. So we can say
00:47:52.400 chrono unit hours. And now we have our completed on. So completed on how many miles did we run.
00:47:59.600 Let's say we ran five miles. And what is the location. So I'll say location dot outdoors
00:48:06.240 because it's nice today. I want to get outside and run. So all I want to do is go ahead and
00:48:11.440 log that now because one thing I didn't mention here is the class that we created had all those
00:48:18.880 getters and setters and equals and hash code and two string. A record has all those components as
00:48:25.520 well. The nice thing is though this is immutable. Once you create this record you'll see there's no
00:48:30.640 constructor here. There's no all arcs. There's basically an all arcs constructor. We create an
00:48:37.040 instance of the run and then we can get at the values but we can't set them. We can't change
00:48:42.640 them later. And that means that this class is immutable. But it also means this class comes with
00:48:48.640 a two string and equals and hash code getters for all of those fields or they're called record
00:48:54.960 components here. But all the mechanics that we need to create a run and get all of that information
00:49:00.240 is there. So let's go ahead and rerun our application. See what we have. And now the
00:49:06.240 two string is automatically called. It says, hey, here's the run ID one. Here's our title. Our
00:49:11.760 started on our completed on miles is five and the location is outdoors. All right. So with that,
00:49:19.600 I think we have all of the kind of infrastructure, the knowledge to kind of get around
00:49:26.160 our application. We've written some code. We have this run. We have this location.
00:49:31.040 That's really everything we need to start building a rest API. We'll call module two complete and
00:49:38.000 we'll head over to module three where we are going to create a web application together. We're going
00:49:43.200 to create a rest API using Spring MVC. All right. So this is module three web applications using
00:49:51.920 rest APIs. Now we have our application running. If you look down in the council,
00:49:56.880 we see that Tomcat has started on port 8080. All this means is that we have an embedded Tomcat
00:50:03.760 server. So something that can serve up an application and take requests and return responses
00:50:09.760 and that it's running on 8080. This means I have an app. I should go ahead and test it, right? Let's
00:50:14.640 hop over to the browser, go to localhost 8080. I'll just refresh this and you see that there's an
00:50:20.240 error. That's because we haven't done anything yet. We have not set up any endpoints for this
00:50:26.560 application to respond to. So we're going to do that now and we're going to talk about really
00:50:32.240 quickly Spring MVC. So MVC, if you've come from another language, another framework,
00:50:38.320 you might have done this before. MVC stands for Model View Controller. Model is the thing or the
00:50:45.120 type that we're going to work with. In our case, we've already built out the run and the location.
00:50:50.720 So that is the model. The view is how are we going to represent this thing, this run in our system.
00:50:57.440 Sometimes you might display this in like an HTML page. In our case, it's a rest API. So where the
00:51:03.040 view is going to be the JSON that is returned as data. And then the controller. The controller is
00:51:08.960 the traffic cop of our system. It is going to take in a request. It is going to figure out what we
00:51:14.080 need to do with it, delegate to some other service to do things, and then return a response.
00:51:19.840 Controllers are very dumb. Take in a request, return a response, don't do anything else.
00:51:24.560 So we're going to have to delegate to some other classes to do those things.
00:51:28.320 So that's what we're going to start doing is we're going to create a run controller.
00:51:33.040 So I'll come into my run package. I'll create a new Java class. I'm going to call this run
00:51:37.520 controller. You can call it whatever you want. It doesn't need to end in controller. It's just kind
00:51:42.720 of a convention that you'll see in the spring world. And it makes it easier to kind of just
00:51:47.520 look at a file name and say, OK, I realize that that is a controller. So I'm going to make this
00:51:52.400 a controller. And if you did nothing else, this would not work. Right. So there are these things
00:51:58.720 called annotations in Java. And if you've been around Java, you've probably seen them.
00:52:03.280 And these annotations kind of add some behavior to your classes, to your methods, to your fields.
00:52:11.520 And so you'll see a lot of annotations in spring because it cuts down on the verbosity of having
00:52:15.680 to write all this extra code. So what we're going to do is we're going to use a couple of annotations.
00:52:20.480 One is going to be REST controller. And it says, hey, this is a controller. It's a REST controller.
00:52:26.400 So we expect the response body to be in some form by default. This is going to be JSON.
00:52:32.720 So we're saying that this is a REST controller. Now we can go ahead and create a method. Let's
00:52:37.280 say public. And I don't even need it to be public. Let's say it's a string. And we're going to say,
00:52:42.800 let's just call this home. And we're going to return hello runners, basically our application.
00:52:48.960 What we need to do is map this method to an endpoint to say when somebody accesses a specific
00:52:54.080 endpoint, here's the method I want you to execute. So we can do this a couple of different ways.
00:52:59.680 There is a request mapping annotation. And this takes both the path and the request method. So
00:53:07.360 in this case, it would be a get. Now there are specialized versions of request mapping that I'll
00:53:12.960 probably use the most. These are for each of the request methods. So get mapping, put, post,
00:53:19.920 delete, etc. So I'm going to say that this is a get mapping to slash hello. And that's all we need.
00:53:27.360 So if we go ahead and rerun our application, now there'll be an endpoint for slash hello.
00:53:32.640 This method is executed. What is returned in this response is just a string, hello world.
00:53:39.440 So let's go ahead and look at this again, nothing at the root. But if we go to slash hello,
00:53:46.080 there is our string that's being returned. Hello runners. So that is kind of the crux of that's
00:53:52.400 the getting started of a controller. Now what I want to do is really start to build out a crud
00:54:00.240 controller, a crud REST API, where we can interact with the runs in the system. Now the runs in the
00:54:07.680 system are going to be in memory first. Let's walk before we can run, let's create an in memory
00:54:13.920 representation of all the runs in our application. And then we can play with those we can return one,
00:54:19.680 we can return all we can create a new one, etc. Now what I said before was that controllers
00:54:26.880 are very dumb, they shouldn't be doing a whole lot of other things. So one thing I could do,
00:54:31.680 I could come in here and say I have a list of these runs, I want you to go ahead and manage
00:54:36.880 these for me, we'll call them runs, let's say new array list and boom, we can go ahead and start
00:54:43.440 managing the runs here. But again, the controller should take in a request, return a response,
00:54:49.840 not manage any other logic, do anything else. So what I'm going to do is split this out into
00:54:54.960 another class and delegate those operations to something else. So I'm going to call this a run
00:55:02.160 repository. So there's a repository pattern for data access and we'll kind of use that. We're not
00:55:10.560 accessing a database, but we are going to encapsulate some of that like data access there.
00:55:15.440 So I'm going to call this run repository. And I'll go ahead and create this here. So now I have a
00:55:22.480 list of runs. Alright, and in this run repository, the first thing I might want to be able to do is
00:55:27.520 get all of the runs. Now there are no runs, all we did is initialize this list, there are no runs in
00:55:32.320 there yet, we'll come back to that in a second. So I may want to say, hey, I want to return a list
00:55:37.280 of runs. And this method is going to be called find all. And what you should do is return runs.
00:55:42.640 Great. But again, Dan, there's no runs in the system yet. How can we do that? So in a class,
00:55:49.600 there are some different annotations that we can use in the lifecycle construction of a class.
00:55:55.760 Again, we talked about beams and application context. We'll start to dive into those more,
00:56:01.360 some of this will start to make more sense. But in the creation of this class, when it's
00:56:07.120 gets put into the application context, it follows this lifecycle. One of the annotations that we can
00:56:14.480 use here is post constructs. Let's go ahead and take a look at that. And what does this say? It
00:56:20.480 says it's used on a method that needs to be executed after dependency injection is done
00:56:26.160 to perform any initialization. So this is going to do some initialization in this class. Just think
00:56:32.880 of that. Don't worry about dependency injection and stuff like that. So I'm going to call this,
00:56:38.480 this actually needs to be a private void, a knit, and then we can go ahead and add some runs. I'm
00:56:45.440 going to pay some code in so we don't have to watch me type this out. So the class gets created,
00:56:51.840 this method gets called, we add two runs to our list. Now we have some runs in the system. So if
00:56:57.520 we call find all, we can get a list of those runs. Now it's time to start talking about some more of
00:57:05.360 these annotations. So again, I talked about in the run controller, we mark this with that rest
00:57:10.400 controller. If we were to move this away, this class wouldn't work, it wouldn't be able to respond
00:57:14.960 to requests. And that's really what this rest controller annotation is saying. Hey, I am a class
00:57:20.960 that responds to requests, returns responses, right? So this is one of those annotations.
00:57:26.800 There happened to be a bunch of annotations in spring. And again, you can kind of command click
00:57:31.600 into them. This is actually annotated with at controller, which is another special stereotype
00:57:38.880 annotation and at response body. So it's actually made up of two annotations. But the at controller
00:57:46.000 is actually made up of another annotation called at component. And that component is really what
00:57:51.600 tells spring, hey, I want you to manage this class for me, the lifecycle of this class,
00:57:57.680 the dependencies that this class has, you are in charge of this class. At the run repository level,
00:58:04.720 I haven't done anything yet. I'm saying I'm managing this class, I'll worry about this class.
00:58:09.360 But what we really want to do is tell spring, hey, I want you to be in charge of this. So I could add
00:58:14.960 at component and that would fix things. But there's also specialized versions of this, one of which
00:58:20.960 is at repository at service at control or at risk control. These are no more than just at component
00:58:27.920 annotations. But if you wanted to do something fancy, like, hey, find me all the classes marked
00:58:32.400 with at repository, you could. So this is now in the application context. So spring has an instance
00:58:40.480 of this class for us. That's important to remember. We'll come back to that in a second. So we have
00:58:46.480 this class that has the ability to store runs. We have a method that can find all the runs in the
00:58:53.520 system. So what I want to do is go back to my run controller. And I want to go ahead and get rid of
00:58:59.840 this. And I want to write a method that will return a list of runs. Because again, the run
00:59:07.600 repository isn't available to the public. The controller is what takes in a request. That
00:59:13.280 request is, hey, I need all the runs and returns the responses. Here's all the runs. So this
00:59:19.200 controller method is saying, hey, here's a list of runs. I am going to call this find all. And how am
00:59:25.680 I going to get a list of runs? Let's just call it null for right now. So now, to return all the runs
00:59:33.200 in the system, I need to get an instance of that run repository, right? So one thing I can do is
00:59:40.960 say run repository. I could go ahead and create a constructor. I'm going to go none at this time
00:59:47.360 because I want to show you the wrong way to do it first. And this is the wrong way to do it.
00:59:52.960 So let's talk about it. So I'm saying the run repository in this class to create a new instance
01:00:00.880 of this, just use the new keyword like we are used to doing in Java and create a new instance
01:00:06.640 of the run repository class. As we've talked about, Spring is an inversion of control framework.
01:00:15.280 Anytime you see the new keyword, when we're creating new instances of something other than,
01:00:20.960 say, a type like a run, when we're creating new instances of classes, a little alarm bell should
01:00:26.880 start going off in your head and go, why am I creating a new instance? Spring probably already
01:00:32.400 has an instance of this. And by the way, it does some other things in there like run that
01:00:38.320 post construct for me to initialize that data. So anytime you see a new keyword, start to think
01:00:44.640 about that and think, okay, maybe I don't want to do this because what if this controller takes in
01:00:51.200 a thousand requests? So you visit this controller, I visit this controller, 800 other friends visit
01:00:57.760 this controller. Every time we hit this controller, we create a new instance of the run repository.
01:01:05.440 And that's not what we want. There's only one run repository. It's a singleton in our system.
01:01:12.400 And so we want to just get the one that Spring has available to us. And this is what is known
01:01:18.560 as dependency injection. So instead of doing this, what we're going to do is we're going to ask for
01:01:25.200 an instance of that. So we're going to ask in the controller's constructor for a run repository.
01:01:31.920 And I'm going to call this run repository. And then I'm just going to say this.run repository
01:01:37.760 is equal to the run repository that gets passed in as an argument. Now in IntelliJ here, I can see
01:01:44.720 that that worked because I have this little gutter icon saying, hey, I see a run repository and I
01:01:50.080 manage it. I can go ahead and do that for you. Now just for fun, let's take this annotation off
01:01:56.160 and go back to our run controller. Now Spring is saying, hey, I can't auto wire one of those in
01:02:02.240 for you. I don't have one of those things. I don't have an instance of that because you haven't told
01:02:07.440 me about that class that you're creating. So you can go ahead and undo that and that will fix that
01:02:15.200 issue. Now sometimes you will see in older code, you'll see an at auto wired annotation
01:02:22.720 right on the field itself. This is what's known as field injection. And this is not
01:02:28.720 suggested and actually IntelliJ right here will say, hey, field injection is not recommended.
01:02:34.560 There are some reasons not to do this. One of most is testing. If I wanted to be able to mock
01:02:39.600 out this repository and pass in a stub or a different version of it, it becomes very hard
01:02:44.960 because this is using reflection. So what happens is it's actually doing that on the
01:02:52.160 constructor. But because there's only a single constructor there with some arguments,
01:02:57.360 this is implicit. So you don't need to add that annotation. So at the end of the day, there's a
01:03:02.480 run repository. Spring knows about it. It can inject it into this controller when it creates
01:03:07.760 an instance of it. And we have a class that we can now use. Now we have a run repository.
01:03:13.280 Now we can say, hey, the run repository has a find all method.
01:03:17.280 Let's call that to return all of the runs. Now we need to create that get mapping again. Again,
01:03:23.920 there is no there's no mapping. There's no endpoint for someone to visit. So what I would say
01:03:30.160 is let's go get mapping. And I think I have I'm just checking the final and I'll say this is at
01:03:37.280 slash API slash runs that will return all of them. So let's and actually we don't need to go
01:03:43.200 ahead and restart our application because it will restart for us. So let's go back over to the
01:03:49.200 browser. And let's go to slash API slash runs. And let's turn it down a little. And now we see
01:03:58.000 the when we execute that endpoint, we get all of the runs back. So we have two in the system
01:04:03.600 because we loaded two up in that init method. And so it's bringing back those two runs.
01:04:10.080 Pretty good so far. Let's start to improve upon this a little bit. So first off, this slash API
01:04:16.400 runs, I might start to replicate this or duplicate this over all of the crud methods in my system,
01:04:23.040 right? So I might have a get mapping for slash API slash runs slash whatever ID for API slash
01:04:32.800 runs for the post for the put delete, etc. So what I'm going to do to like cut down on some of
01:04:38.480 that duplication is I can set a request mapping at the controller level. So this is API slash runs,
01:04:46.080 and then every method that has like a get mapping a post mapping to put mapping falls under that
01:04:52.480 base URI, right? So now what I can say is, this is nothing, this is slash API slash runs,
01:04:59.840 that will call find all, then I can say slash API slash runs slash ID, that will return the ID,
01:05:08.480 right? Or that will return just one. So let's actually do that real quickly. Let's say run
01:05:13.200 find by ID. And maybe we want to use the run repository to find by the I'm just hard coding in
01:05:24.240 a value of one because we'll come back and we'll fix that in a second. But let's go back to
01:05:29.760 our run repository. And let's create a method that returns a run called find by ID, and takes
01:05:37.680 in an ID, and then says that looks pretty good. Actually, we don't even need to throw an exception
01:05:44.160 first. And we know this will work. So I'm okay with that. So let's just do that for now again,
01:05:51.440 not the most ideal place to do it. But this will work. So now I can go ahead and rerun this
01:05:59.120 application again, don't need to dev tools has restarted for me. And now I can go to slash runs
01:06:04.960 slash one. And I get just that specific one. I can't go to slash two or three yet, because we've
01:06:11.920 kind of hard coded that in there. And so that's kind of the next place that I want to talk about
01:06:17.520 is being able to use dynamic variables in these paths. So we have a slash one here, but we really
01:06:24.240 want a placeholder for an ID, right? We want to say, hey, whatever is in this path, I'm going to
01:06:30.800 consider an ID. And I want you to use that ID. Now, the way that we get that and pass it to our
01:06:37.280 method, our find by ID method here, is by using an annotation called path variable. So that path
01:06:44.080 variable is going to pick it out of the path and assign it to whatever we create here. And I'm going
01:06:49.840 to say that is going to be an integer of ID. So we can pass that now. Now this is dynamically
01:06:56.480 passing whatever is in the path to this particular method, and should go ahead and use that.
01:07:05.040 Still saying we have an issue, but I don't think we do. So I'm going to go ahead and save.
01:07:12.000 Let's go back to our browser, see if one still works. It does. Let's see if two works.
01:07:18.480 It does. And now we know that something like 99 is not going to work. It just returns an error
01:07:24.240 because we haven't handled that exception. So, so far, so good. This is off to a good start.
01:07:30.960 All right. So one thing I'd like to improve on right away here is the find by ID when we passed
01:07:36.160 in 99 through an error. And so let's go ahead and fix that. I want to go ahead and instead of
01:07:42.240 returning a run here, what I want to do is actually return something called an optional
01:07:48.400 of run. So what is an optional in Java? If we go ahead and click through, take a look at this,
01:07:54.800 it is a container object, which may or may not contain a non null value. If the value is present,
01:08:02.240 we have this method called is present that will return true. So it's just a way of being able to
01:08:09.120 operate on objects without having a null value present. Right. All right. So to fix this,
01:08:14.880 I'll just remove that and that will return an optional. So back in our run controller,
01:08:22.240 we're going to have to kind of change things up here. What we want to do is we want to check to
01:08:27.040 see if it's there, if it's there first. So in this case, I will not return this. I'll say run
01:08:32.880 repository dot find by d dot far is going to return an optional run. We'll call this run.
01:08:40.160 And then what I want to do is say if the run dot so you can do a couple of things you can say is
01:08:46.800 empty or is is present. So if it's empty, I want you to throw a new exception and we're going to
01:08:54.640 call this. Let's actually do a response status exception. And we can say HTTP status not found
01:09:06.800 and our run not found. Now we can also throw a custom exception here. Talk about that in a little
01:09:11.359 bit. But if not, I just want to return the get method. So I'm actually returning the run that
01:09:18.160 we retrieved. So this should be a little bit better. We're actually I saved the file,
01:09:23.760 reloaded. Let's go back to the browser and try to look at run 99. So now we get a 404 not found
01:09:32.880 instead of that 500 message. Now, one thing we've been looking at is just kind of testing this out
01:09:38.319 in the browser. But I also want to show us that we could do this in the terminal from a command
01:09:42.640 line. You can use whatever command line tool you're familiar with. There is curl curl is great
01:09:48.880 because it's installed on everybody's machine. But it's also there's a lot of things you have
01:09:52.319 to understand about curl. I like this program HTTP because I just type in HTTP what I want
01:10:00.400 to what port I'm on. So in this case, 80. So this is basically a request to HTTP localhost 8080.
01:10:07.760 And then slash API slash runs. And we can see that because we've kind of switched context,
01:10:14.480 right, we're no longer in the browser, we're on a command line. We're able to get back the response
01:10:20.320 here, here's some of the headers. So we're using HTTP one, one, here's the content type. So we're
01:10:27.040 using application dot JSON, here is the response. Now I can say, give me just the first one,
01:10:33.600 or give me that 99th one that doesn't exist. And we'll get a error there. Now, again,
01:10:40.240 this is a 400. We can handle this a little bit better. And we'll do so in the future. But at
01:10:45.920 least that's a little bit better than we were doing before. So we're starting to move along,
01:10:52.400 right, we have our controller methods, we are starting to build out kind of the crud,
01:10:56.640 we have the list, we have the find by ID. Now we need to do, let's say, we need to create one,
01:11:04.080 which is post, we need to update one, which is put, and we need to delete one, which is delete. So,
01:11:11.840 so how can we create a post? Alright, so I'm back in the run repository, I need to create a new
01:11:18.480 method in here to be able to create a new run. So let's go ahead and call this, yeah, what is the
01:11:25.440 return type? Do I need to return the run? Probably not, because I'm passing in all the info, I know
01:11:30.480 what it is already. So I'm going to say void create, it's going to take a run as an argument,
01:11:36.000 and then it's just going to add a run to that list. And that's all we need to do there. Now,
01:11:41.440 this run is basically going to be immutable, right? So do we need, so that should work. Let's
01:11:50.640 talk about it from a controller's perspective. How are we going to handle this? So I'm going to
01:11:57.040 create a method to create one, so I'll say void create, and it's going to take in a run somehow,
01:12:03.920 we'll come right back to that, we'll use the run repositories create method, and pass in that run.
01:12:10.080 Now here's where it gets a little bit interesting, we have this run. And what we need to do is we
01:12:14.960 need to somehow tell this controller that this run that is getting passed into us is going to be
01:12:20.160 coming from the request body. So if you've ever worked with a REST API before, you know that you
01:12:26.080 like will hit a certain endpoint, and you pass in a body as part of the request to use. And that'll
01:12:33.200 in this case be in the form of JSON, it'll be a JSON object with the ID title started on created,
01:12:39.600 you know, what are all of those fields as part of that request. Now the way that we tell Spring
01:12:44.720 that hey, this argument is going to be part of the request body is as you guessed it, an annotation,
01:12:51.920 we're going to say request body. And now it knows, okay, this is coming in as part of the request body.
01:12:59.920 So this is great. Up until now, we've been testing everything kind of manually using
01:13:05.600 the browser and the command line, which is easy for get requests, right, because a browser can
01:13:10.880 respond to a get request, our command line is easy to use with a get request. But now we have
01:13:16.560 to send a post request. And we need a tool to do this in. So I talked about this in prerequisites.
01:13:23.840 But basically, there are a couple options, we could do this from the command line,
01:13:27.200 it's a lot to remember, I'm a visual person, I like to be able to see it run. So there are two
01:13:32.800 tools that we can take a look at here. And I have a in the main repository, actually, let's go back
01:13:40.080 to the browser. If we go back to the main repository, you'll see an API folder. And in
01:13:46.000 the API folder, you'll see a postman collection. And I HTTP file, this is the IntelliJ's collection.
01:13:54.160 So if you're in postman, you can load up this collection, there's a way to import that by
01:13:59.040 opening that file. And now what I can do is just click on one of these. And actually,
01:14:03.120 let me close all of these, because I think some of these are older.
01:14:08.160 Don't care, don't care. Don't care. All right. So now that I'm in here, I'm in the final,
01:14:17.120 you can see that it's going to localhost 8080 slash API slash runs. And it's a get request,
01:14:22.400 we can send that request, we can get to the pretty view. I'm sorry, where's the pretty view of all
01:14:28.640 the runs in the system, right? We can go ahead and find by ID, we know there's one in there with
01:14:33.520 an ID of one, we can get that back. Now we can start to use the other ones here, this is the
01:14:38.800 create one. So this is going to send a post request to localhost 8080 slash API slash runs.
01:14:46.480 And this is the request body, we see that we're sending it raw, but this is also a JSON type.
01:14:52.640 So we're sending in this request. And I think I may need to update this because
01:14:59.360 this one is for probably the end result, where in the case of a database, we may not send an ID.
01:15:06.400 In this case, I'm going to hard code the ID and then I'm going to send because again,
01:15:10.800 this is an in memory collection. So I'm saying here's my third run, send a post request,
01:15:17.120 and then go ahead and make this happen. So I'm going to send this and see what happens.
01:15:22.080 We get a 405 method because it is not allowed. So let's go back to our code. And the reason for this
01:15:28.320 is we haven't annotated any methods in here with a post mapping annotation. So the only methods
01:15:35.440 allowed by default are I believe get an options, I don't even know if options is by default. But
01:15:41.840 what we want to say is, hey, I have a post mapping here. And all we're going to do is use the empty
01:15:48.000 rack empty parentheses here, because again, that's going to go to slash API slash runs.
01:15:53.760 So I've saved that, I'm going to come back over here and attempt to do this again.
01:15:58.800 And you see nothing is returned. Because again, we said void, don't return anything. But I also get
01:16:05.520 like a 200 back. And I'm not really sure like if something got created. Now one way I could check
01:16:11.200 this out is going over to find all and clicking send. And oh, there's a third run in our system,
01:16:17.280 it did get created. But I wasn't really kind of notified that it was created. So I'm going to do
01:16:24.160 one more thing here. And I'm going to add another annotation here called response status. And what
01:16:30.160 I wanted you to do is if you're going to return something, in this case, you're not returning
01:16:34.400 anything, you're returning a response, though, I want you to send the response status of HTTP
01:16:40.560 status that created this is a 201, as opposed to a 200. And what this does is it notifies the sender
01:16:50.880 that something did happen, it was created. So I'm going to go ahead and send this again.
01:16:56.400 Now I see that I got a 201 created, I don't even need to go check anything else. I know it's there
01:17:01.360 because of that response status that was sent back to me. So just one little nice feature that
01:17:06.800 we can add to go ahead and update that. Okay, so we're getting there. I'm going to go back to our
01:17:13.760 repository, we need to add a couple more methods for updating and deleting. So let's go ahead and
01:17:22.800 do the update. Let's say void update. Oh, boy, you're getting good. Co pilot. So I'm going to
01:17:30.240 say optional run is, hey, let's find the existing run that you're asking me to update. If it exists,
01:17:38.160 so if that existing run is present, remember, the optional returns back,
01:17:43.040 this optional that has an is present method on it, if it is present, I want you to go ahead and set
01:17:48.960 the index of that existing run to the run that I passed to you. All right, so that's one thing.
01:17:55.440 Now let's say, what if we wanted to delete runs, go ahead, this is a collection, remove if
01:18:05.200 the run.id equals the ID that we passed into. That looks pretty good. So now I'm going to go
01:18:11.120 back to the controller. We're going to create a couple methods here. So the first one is going
01:18:16.880 to be a put. So we're going to say void update. So we're going to get the run just as we did in
01:18:22.880 the create, we're going to get this through the request body. Then we need the ID of whatever
01:18:31.120 run we're trying to update. So at path variable, integer ID, use the run repositories to update
01:18:38.480 that. That looks good. But now we have no way to respond to this yet, because we haven't created
01:18:44.640 an endpoint. We can do so by using the put mapping annotation, and the ID as a dynamic variable,
01:18:53.280 because we've assigned it using the path variable. So now we can respond to a put request. Now we can
01:19:00.240 respond to gets, posts, puts, how can we respond? And actually, let's come back one more thing.
01:19:07.280 I'm going to add one more response status. And I'm just going to say no content, like it's okay,
01:19:12.160 this is a 200. I'm sorry, instead of sending a 200, this is done. We actually have no content
01:19:19.760 to send back to you, right? Just again, informing the user of what's going on. So we'll do that here
01:19:25.920 as well. I'll also say that this is a delete mapping to slash ID. And then we'll just say void
01:19:34.320 delete path variable. Yes, call that. So don't worry if we're not following along all these methods,
01:19:41.600 don't worry, we're just kind of building out the crud of the system. We'll kind of enforce this as
01:19:46.080 we go along, and we move away from the in memory representation to say a database call. So we've
01:19:52.640 restarted, I'm going to go back to postman. So now, the system is restarted. So there's only two in
01:20:00.800 there right now, right? Because we've sent because it restarted. And when it does, it initializes
01:20:06.880 those two runs. But now we can go in and we can create one. So let's go ahead and create one. We
01:20:11.840 got a 201. So we know that's been created. In this case, we're going to update three. So whatever
01:20:19.440 that was before, we're going to call this and say update that we have a 204. So not a 200 204 says,
01:20:26.560 yes, everything was done. Everything was successful, but I have nothing to send back to you. And that's
01:20:32.000 okay. So now we know that that's there. Let's go ahead and look at that. And there's our three with
01:20:38.640 our updated record. And then finally, let's go ahead and delete one. So I'm going to call localhost
01:20:45.840 8080 slash API runs three. So if I send that in, we also get a no content. And if I go back to find
01:20:52.960 all I only have my two in my system. So that's postman being able to test your API. That's
01:20:58.960 important. I also included a collection for using an IntelliJ. And I think I'll do that. I'll copy
01:21:07.680 that into this project. So let me say API. And let me find that. And so if you're using the IntelliJ
01:21:17.040 Ultimate Edition, you can come in here and just click on this, you can actually run these right
01:21:21.440 in IntelliJ, which I like not having to leave the ID. Here is the two in my system. If I wanted
01:21:27.600 to get a one by ID, I can. If I want to go ahead and create one, I can. All is good. Now, again,
01:21:35.520 you can do this through postman. You can do this through IntelliJ. You can do this through Curl.
01:21:39.680 But as we start creating these methods, it's good to manually test these. We will write some tests
01:21:45.760 for these letter, these automated tests. But this is good. Just a kind of good sane check to make
01:21:50.960 sure everything is working OK. All right. Now, one thing I'd like to do is kind of improve on
01:21:57.040 some of the error handling that we're doing here. We could go into a lot more detail on this. But
01:22:02.480 just for the sake of time, I'm just going to kind of clean up one thing here. So I have this throw
01:22:07.840 new response status exception. Hey, response not found. But we can kind of clean this up and
01:22:13.760 actually create our own exceptions. What I'm going to do is go into main Java into run. And I'm going
01:22:20.320 to create something. So new class run not found exception. Right. That looks good. And this is
01:22:29.360 going to extend the runtime exception class. And we can just say run not found. But more importantly,
01:22:36.400 I'm going to add that response status on here and say, hey, this is a not found. So I want you to
01:22:42.400 return a 404. So now back in here, I can just say throw new run not found exception. Let's see if
01:22:52.400 that saves. Let's go back to maybe our test here. Let's go ahead and do this in here. And let's just
01:23:01.600 say that we try to find by an ID that doesn't exist. So let's copy this and say by ID that doesn't
01:23:14.320 exist. And let's say 99. So let's go ahead and try and run this. And now we just get that nice 404.
01:23:22.640 Hey, this is a run not found. Here's the path so we can see that it's API slash run slash 99.
01:23:31.040 So that's kind of one good improvement. Something else we need to think about
01:23:36.240 is when we're creating these new runs, we probably want to validate some data, right? Like, if we
01:23:42.240 just accept whatever the user sends us, that's probably not going to be a good time. We need to
01:23:47.200 make sure that whatever they're sending us is valid data, right? So there are a couple different
01:23:53.840 ways to do this. I'm going to show you two. I'm not a big fan of mixing and matching these,
01:23:58.880 but I just wanted to kind of show you both ways to do this. So one thing I want to do is I want
01:24:05.360 to make sure that when we create a run, so here is a constructor for a record, I want to say if the
01:24:14.640 completed, if completed on, sorry, that should be that, then what I want you to do is throw a new
01:24:23.040 illegal argument exception and saying, hey, that completed date that you sent me has to be after
01:24:29.360 started on. You couldn't have finished a run before you started it, right? So that's one level
01:24:35.040 of validation that we can do. Another is by using something called the validation API.
01:24:42.640 And this is going to be an extra dependency that we need to bring in. So this is one of those things.
01:24:48.640 If you're on start.spring.io and you go through your dependencies, you can select validation and
01:24:53.920 that will bring it into your project. But as I said, there are going to be times where you're
01:24:57.920 working in a project and realize you need another dependency and we need to go ahead and bring this
01:25:03.280 in. So I'm going to type in dependency here and I'm going to say spring boot starter validation.
01:25:11.600 And that's going to come from org.spring framework.boot. And if you're in IntelliJ, you need to
01:25:18.960 click this little reload button that says, hey, bring in those external dependencies that we just
01:25:23.440 declared. And now we can use them. So now in my run, now I can use the being validation API.
01:25:30.800 And with that comes a bunch of constraints. So one thing I could say is, hey, I don't want this title
01:25:36.160 to ever be empty. So how can I do that? I can use the not empty annotation and you'll see
01:25:42.560 that it comes from Jakarta validation constraints, not empty. If I look in the constraints package
01:25:49.680 here, you'll see a bunch of different constraints that we can use. Hey, make sure that this is an
01:25:55.040 email. Make sure it's in the future. Make sure it has a min or a max. Make sure it's not null,
01:26:00.240 past, past or present. There are all these validations that we can take advantage of here.
01:26:06.000 So I'm going to put one more on miles and make sure that it's positive. I don't want you to be
01:26:11.760 able to enter negative five miles because an integer could be negative. But in the case of miles,
01:26:17.760 that shouldn't ever be negative. So now I have some validation constraints around this.
01:26:24.800 This will automatically get run anytime we create a new instance of a run. So we're not worried about
01:26:29.600 this one, but these are validation constraints saying, hey, when somebody asks, asks if these
01:26:37.760 are valid, I can let you know if they are or not. So one way we can do that is in the run controller.
01:26:43.680 When someone creates a new run, hey, please go ahead and validate it. So we're using the
01:26:51.280 at valid annotation. So before we even call this run repositories create method,
01:26:58.240 Spring is going to validate that the object that's getting passed in is valid based on the rules that
01:27:04.880 we gave it. If it's not, it's not even going to go here and it's going to throw a 400 bad request,
01:27:11.520 again, letting the user know that something went wrong. So this has been saved. I'm going to go
01:27:17.760 back over to my runners here. And I think I have an invalid one in here. Yeah. So here's one. Let's
01:27:25.600 go ahead and remove the title to you. So I can see this and I can go ahead and try and post this.
01:27:32.320 And right away it's going to say, hey, that thing that you're trying to create the completed on must
01:27:39.120 be after the started on. Okay. Well, that's good. I've got some information there. That looks like
01:27:45.440 it's working. So let me fix the completed on and the started on so that those are valid and let me
01:27:51.840 run it again. And, um, you are response body to a one. Oh, because we have a title there. Oh,
01:28:01.040 that's why now this should, I think I did the wrong one, right? Um, nope, that's still sending
01:28:08.640 a two or one. So let's make sure that we are validating this title. So run not empty. That's
01:28:18.000 true. We don't want it to be empty. And in our run controller, we are saying at valid. We actually
01:28:26.960 want to do this here too. Um, let me just make sure that the server restarted. It's okay. Doing
01:28:34.480 a little debugging is fine. Uh, let's try this again. Let's go over to runners and let's create
01:28:41.200 a new post. And, uh, now we get our 400 and we're saying here are the errors that are happening
01:28:48.880 with this. If you don't see all of this verbose logging of what went wrong, then you might not
01:28:55.360 have DevTools on the class path. Remember, one of those things that I said that DevTools does for
01:29:01.440 you is restart your application. When your code changes, another thing that it does is sense some
01:29:07.520 sensible defaults and this default to kind of log out this, um, more information on these errors
01:29:14.400 is one of those things. So it says, Hey, validation was run. There's a problem. Where is it?
01:29:20.080 It's on the title and the title cannot be empty. So we're seeing some information there. And if
01:29:25.680 we go ahead and fix that title, which we did in the good example, then it will go ahead and run
01:29:31.600 and save our new run. So that's a little bit about validation. Again, you can kind of do it
01:29:37.600 at the class level. This you could also write a custom constraint for. So there were all the
01:29:43.360 constraints that we saw. Um, there are some, there's a way to write custom constraints.
01:29:48.640 I will say when it involves another property, it can get a little bit more detailed on how to write
01:29:55.280 those custom constraints. So I found this so much easier. Again, I, I don't know how I feel about
01:30:01.040 mixing and matching these, but I just wanted to show you that you could do that validation there.
01:30:05.760 You can also come in here and do that same validation, right? Like if, uh, title that is
01:30:13.680 empty or is blank, then go ahead and throw some illegal argument exception there as well.
01:30:19.680 So that's a little bit about validation in your API. All right. The last thing I want to show you
01:30:25.280 in this module before we move on to talking to databases is we haven't really touched this
01:30:31.440 application.properties yet. We really haven't had a need to do so. Uh, so here's where we can start
01:30:38.240 to configure all of the things in our application. We know if I run the application, I look at the
01:30:43.840 council, we know that, uh, Tomcat has started on port 8080 because this is the default,
01:30:50.720 but most everything can be configured. So in the case of Tomcat, maybe I already have something
01:30:56.800 running on 8080 and I want to run Tomcat on a different port. You can come in here and change
01:31:03.520 that. So server.port, you see the default is 8080, but if I wanted to change this to 8085,
01:31:11.680 I can do that and run this and I can see that now it's running on 8085. So I need to run all
01:31:18.560 my requests through that port. This is simply to say that there are a bunch of properties that we
01:31:24.640 can change about the way our application is working. Um, you know, spring is a convention
01:31:31.680 over configuration framework, meaning if it's nothing's there, it's going to configure something
01:31:37.040 for you. But if you want to go ahead and configure it and change something, you by all means do so.
01:31:42.960 It'll back off and it'll say, okay, I've been told what to do here. These are all the properties
01:31:48.720 that are based on whatever type of application we're building. So in the case of a web app,
01:31:54.240 we are configuring a server and all of the things that go with that. I would say, look at this spring
01:32:00.400 documentation to see what properties are available based on the type of application that you're
01:32:06.000 building. There are also ways to create your own properties. I'm not sure if we're going to get to
01:32:11.760 that today, but if we can, I'll sneak something in. If not, go ahead and check out my YouTube
01:32:16.720 channel. I know I have some videos over there on creating your own configuration properties.
01:32:22.560 So I just wanted to mention that because that's going to be important once we get into the database
01:32:28.240 side of things and configuring database connection. So I think with that, we have, I think you should
01:32:35.200 go ahead and give yourself a big pat on the back. You have created a CRUD REST API in Spring.
01:32:42.480 This is the boilerplate of building REST APIs, right? We have this CRUD thing that allows us to
01:32:48.000 list, create, read, update, delete for a specific type, in this case, a run. So this is the foundation
01:32:56.240 for building REST APIs. We've got that. You've got everything you need to start doing that.
01:33:01.600 Now what we're going to do is we'll move on to the next module and we'll replace this kind of
01:33:06.560 in-memory thing that we've done. So we've done this where we have a collection of runs just in
01:33:11.920 our system. And we'll replace this with actually talking to a database. All right, module four,
01:33:18.720 talking to a database. Now, if you've been around the world of Java for a while, you know that it
01:33:24.560 may not be the easiest thing to connect to a database. There's a lot of things you have to
01:33:28.160 keep in mind. Like when I open a connection, I have to close it. Maybe I'm working with a
01:33:33.280 connection pool. I have to use some of the APIs that have been around in Java since 1.1
01:33:40.720 to access a database. And some of them are clunky, may not be the easiest things to use.
01:33:45.760 I'm happy to say that Spring has many layers of abstraction for working with databases. And it's
01:33:52.240 really easy to get started. In fact, the first thing that we're going to do is talk to an
01:33:56.480 in-memory database. And it's super easy to get up and running. We're going to do this in our app,
01:34:01.520 but I just want to show you here on the Spring initializer. If we go into add a dependency,
01:34:07.680 there is a dependency for h2 database. It says this provides a fast in-memory database that
01:34:15.200 supports the JDBC API and supports embedded and server modes. We're just going to use an
01:34:22.560 embedded in-memory version of a database first. Again, starting to like pick up the pace a little.
01:34:28.960 We're still kind of walking, but walking fast. We'll start to run in a little bit. We'll change
01:34:33.360 this out to like a Postgres database. We'll introduce Docker and do a whole bunch of fun
01:34:38.160 things. But for first, we're going to use the h2 database. Now to talk to the h2 database,
01:34:43.280 I mentioned there are different levels of abstraction, one of which is just the JDBC API.
01:34:50.480 That's what we're going to use. There's also things like Spring data. We'll mention that in
01:34:54.320 a little bit, but this is a really good place to start. It allows you to talk to the database,
01:35:00.080 connect to it, talk to it using SQL. If we're coming from another platform like language and
01:35:05.360 framework, it makes sense. If you're coming from just Java talking to a database, this is a nice
01:35:11.120 level of abstraction on top of that. So I'm going to choose that as well. What I brought you back
01:35:16.400 here is I wanted to show you another feature of the Spring Initializer. If you go ahead,
01:35:21.360 explore, and actually we're in a Gradle project now, let's choose Maven. If you go ahead, explore,
01:35:26.880 it'll actually list out those dependencies that we need. So this one is a runtime dependency.
01:35:33.440 We're not actually going to use this in production. We are going to also use the Spring Boot starter
01:35:40.080 JDBC. So this is that JDBC API that allows us to connect and talk to a database.
01:35:46.240 So now I can come in and copy those dependencies, go back to my project. I'm going to open up the
01:35:53.600 palm.xml. Again, this is the Maven palm that declares our dependencies. I'm going to come
01:35:59.200 in here. I'm going to paste those in. I'm going to refresh my project. And as long as nothing
01:36:04.080 goes wrong, we now can take advantage of those. So what I'm going to do is I'm not going to do
01:36:09.760 anything. I'm going to rerun this application, not do anything. And I want to look in here,
01:36:14.720 and I see a couple of things that are going on. First, the 885 there. Let's get rid of that.
01:36:20.000 I like to run on 880. That was just showing some configuration changes. And now we're back to 880,
01:36:25.760 and we see a few things here. It says the H2 console is available at slash H2 console.
01:36:32.720 Again, this is because of the Spring Boot DevTools that we've included.
01:36:36.720 It sets some sensible defaults. If you don't have DevTools, you could come in here and say,
01:36:43.120 hey, I want to go ahead and enable the H2 console. That's great, because we want to disable that by
01:36:48.560 default. We don't want you somehow running in production with that and making that available.
01:36:53.440 The H2 console, for those of you who don't know, is this nice UI that you can go ahead and visit
01:36:59.840 in your browser and manage your database. So once we create a table, and it has some columns,
01:37:04.960 and it has some rows, we can do all of that right in our browser. And again, this is just a good
01:37:09.200 starting point, right? We see that it's available. We also see that the Hakari pool, this is the
01:37:15.600 database connection pool, is configured for some URL. So when we talk about databases in Java,
01:37:22.880 we have a JDBC connection using a JDBC URL. It starts with JDBC, then the type, in this case,
01:37:30.400 H2 memory, and then some random UUID identifying the database. So we haven't done anything yet.
01:37:40.720 We just included some dependencies. And I'm happy to tell you that you are already connected to a
01:37:46.240 database. Now we haven't done anything yet, but that's how easy it is to connect to a database
01:37:51.200 in Spring. Now to get rid of this name, I'm going to do a couple of things here. I'm going to say
01:37:55.280 the H2, let's say H2, oops, sorry. I don't know what I just did, Dan. So I'm going to say the
01:38:07.520 data source generate unique name. I'm going to say, no, let's not do that. And I'm going to say
01:38:12.800 the data source.name is going to be runners. So let's go ahead and refresh the application here.
01:38:23.040 Now when I look at this, I see that I have a URL of JDBC each two mem runners. So if I wanted to,
01:38:31.600 I could go ahead and copy that, but I don't need to. And what I want to do is go over to the browser
01:38:38.880 and go ahead and look at localhost8080 slash H2 council, because that's the default.
01:38:45.600 And you can see I have a JDBC URL. So I would copy that out of there if I didn't know it.
01:38:51.120 The username is going to be SA, the password is not, there's going to be no password. I can test
01:38:55.520 that connection. I can connect to it now. And now I have this UI where I can play around with my
01:39:01.840 embedded in memory database. Now remember, in memory means every time we restart the application,
01:39:07.520 everything is going to change. But now we have a database. Now there's no tables in here. We'll
01:39:12.160 change that in a second. But there's no tables in here. There's no data in here, but we have
01:39:17.120 something to get up and running with. So now what we need to do is we need to be able to create a
01:39:23.280 schema and say, hey, this is what my runner's table is going to look like. And then we need to
01:39:28.480 create some code that will allow us to persist and read information from that database.
01:39:34.720 All right. So the next thing we need to do is we need to be able to create a schema
01:39:38.640 for that database. Now again, it restarts every time the application restarts.
01:39:43.120 So I want to have some way of automatically creating the schema. And Spring provides the
01:39:48.080 mechanism for that. What we can do is come under Resources, create a new file, and we'll call this
01:39:53.520 schema.sql. This is a specific name that we're looking for by convention. We're looking for this
01:40:00.880 file. When it's an embedded database, we're always going to run this for you. So I'm going
01:40:05.600 to paste in some schema here. This is going to create a new table if it doesn't exist.
01:40:11.760 And this lines up with the run record that we created earlier. It has ID, title, started on,
01:40:17.680 completed on. And notice that the way that this naming convention is, so we use the camel case
01:40:25.760 in the record. This is using snake case here. I believe that's it. I always get those confused.
01:40:32.000 And that's how we're going to name the fields or the columns in our table. So it started on
01:40:38.080 completed on miles location. The primary key is the ID. So with this in place, I'm going to just
01:40:44.000 restart the application again. Let's go back to our browser and take a look at this. We'll have
01:40:51.280 to log in again. That's OK, though. Once we log in, now we see a run table. Now we can do stuff
01:40:58.240 with the table. We can put data in there. We can read from it. We can do this here in the UI,
01:41:03.440 but I want to do this programmatically in our applications. How can we do that?
01:41:09.600 So first off, let's go ahead. And I think what we'll do is we'll go back to the run repository.
01:41:18.960 Now in the final code that you can get on GitHub, there'll be two different versions of this
01:41:23.840 in memory one, the JDBC one. For simplicity sake, I'm just going to keep this run repository as it
01:41:29.760 is. I'm going to delete all of this, right? So let's just say all of that is gone. That's OK.
01:41:39.600 This is going to cause some issues in our run controller. So I'm going to basically comment out
01:41:46.240 everything for now. But we still have a run repository. So now what we want to do
01:41:53.200 is we want to be able to talk to that database. So how do we do that? Well, we've already have
01:41:58.560 a connection to the database. We just need a way to programmatically access it. So I mentioned
01:42:05.840 there are different layers of abstraction in Spring. If you see some older code online,
01:42:10.400 it's not that old. I mean, before three dot two, we still use the JDBC template.
01:42:14.960 But if you see some older code and you see something called the JDBC template,
01:42:18.880 this was really an abstraction on top of the JDBC APIs that made it easier to talk to a database.
01:42:26.080 In three dot two, we got something called the JDBC client. This simplified that abstraction
01:42:32.560 and really gave us this nice, fluent API for working with databases. So what does that mean
01:42:39.600 to us? Actually, I don't even need this for now. One thing I want to do is get a logger real quick.
01:42:45.600 So we talked about this earlier. I just have a logger that I can use to log in my class here.
01:42:51.600 I'm going to declare a JDBC client. So JDBC client will get this through constructor injection.
01:43:01.040 What this means is we saw this earlier, right? So this is dependency injection.
01:43:05.360 Because we added that JDBC API dependency spring, this is one of the powers of kind of spring boot,
01:43:12.880 looking at things that are on the class path and auto configuring things. So it knows, hey, we're
01:43:18.800 we're going to be talking to a database, I'm going to auto configure you a JDBC client. And now it's
01:43:24.960 in the application context. And if you ask for an instance of it here in the controller,
01:43:29.920 it will pass it to you. You don't need to create one. So we have an instance of a JDBC client.
01:43:35.040 What is a JDBC client? Let's take a look at it. So I'm going to go ahead and download sources.
01:43:41.280 A fluent JDBC client with common JDBC query and update operations, supporting all the JDBC style
01:43:49.280 positional as well as spring style name parameters with a common unified unified facade for JDBC
01:43:56.320 prepared statement execution. So it gives some examples in here. You can dig through here. You
01:44:02.000 can look at the structure of this and find out, hey, there's a SQL, a create, create, create,
01:44:08.320 a very simple API from there, we can do other things. So let's use this to kind of replace
01:44:15.520 the functionality that we had in our in memory repository. So I want to be able to find all of
01:44:25.120 the runs in the database. So what we're going to do is say I want a list of runs, and we'll call
01:44:32.800 this find all. And how are we going to get that? We're going to use that JDBC client. And now the
01:44:44.080 first thing that we need to do is use some SQL. So we're going to have some SQL, and we're going
01:44:49.200 to say select star from run. And once we do that, I want to go ahead and map the results to something.
01:44:59.600 So run that query and map the results to a run. And oh yeah, go ahead and return a list of things
01:45:09.920 back to me. So I don't have an actual connection to the in memory database here from my database
01:45:16.400 tools. So it's going to just give you an error here. But that's okay, we have a connection,
01:45:21.440 everything is going to be working. So I have a way to find all. This is good. But I also don't
01:45:27.760 have any runs in my database. So how can I fix this? So another thing you can do is you can come
01:45:33.920 in here and say, I want to go ahead and insert some data. So you can use data dot SQL. Now this
01:45:39.920 is you're gonna have to write SQL to insert data. I don't do this a lot. But I'm going to do this
01:45:44.320 just for this kind of demonstration. Later on, we'll do this programmatically,
01:45:49.120 we can add some data through through through some code. All right, and I'm just going to paste this
01:45:53.360 in. So we're inserting into run here our columns here are values, let's go ahead and try and run
01:45:59.200 our application. And there we go. Now we have a single run in the system. So with some data in
01:46:06.400 the system and a schema in place, now I should be able to come to my run controller, uncomment
01:46:14.000 that out, we're using the same run repository, we've just changed that code in the repository
01:46:20.320 to actually pull from the database. So now, this is probably restarted. By now, we should be able to
01:46:27.280 just go over to the browser and go to localhost 8080. So we can go to localhost 8080 slash API
01:46:34.800 slash runs. And there's our single run in the system. But now, we're pulling from a database.
01:46:42.480 So this is exciting. We've moved on from this in memory representation to storing some things in
01:46:49.760 the database. Now remember, every time we change our code, it's going to restart the application,
01:46:54.560 and the data is going to kind of reset itself. But we're making some progress. We're doing some
01:47:01.040 some fun things here. So now I want to go through and talk about some more methods that we can write
01:47:07.840 in our repository. So I'm going to go to our run repository. And I'm just going to paste in some
01:47:14.640 methods here because we can talk through them. We don't need to watch me type all of them out.
01:47:19.600 But let's go ahead, we have that find all what about in an instance where we want to find a single
01:47:24.800 run. Remember, in our in memory representation, we return an optional run, we can do the same here,
01:47:31.360 we can say, okay, here's the SQL, I want you to find these columns from run where ID is equal to
01:47:38.800 ID. So we're using a named parameter here. We can set that parameter by calling dot param.
01:47:46.400 The param name is ID. Here's what I want you to pass to it. That is the ID that we got from the
01:47:51.920 argument. I want you to map this to a run. So we have our run. And then I want you to return an
01:47:59.520 optional. So it's a good way to find by ID. Now you'll notice I'm naming these the same as I did
01:48:05.760 in the in memory representation. So that these are in place, our controller should just work
01:48:11.920 exactly the same. Now again, this is for demo purposes, but I thought it was fun. Now,
01:48:17.360 to create, update and delete, we are using something called update in JDBC. update is
01:48:24.240 basically, hey, I'm either inserting something, I am updating something, or I am deleting something.
01:48:30.320 And what happens from that is we, here's the SQL that we're going to run, here's the values
01:48:35.680 I'm getting passed in, I pass in a list of params, I call update, what is returned from update is how
01:48:42.960 many rows were affected. So in this case, we actually want to make sure only one row was
01:48:48.640 affected. If it didn't, here's the message that you could send back. So again, update, we're just
01:48:55.440 making sure one is updated, delete, we're just making sure one is deleted. We're able to count,
01:49:01.200 we're able to, I wrote like a save all method if we want to save a bunch of them. And then just a
01:49:07.440 custom query like, hey, find me all of the ones by the location. So this is, again, if you've never
01:49:15.280 done anything in spring and just worked with databases in Java, this should look pleasantly
01:49:21.840 familiar. It's a little bit easier to read, you get this nice fluent API. And if you've not done
01:49:27.680 a lot of work with Java and databases, and you're coming from another language, I think you should
01:49:32.640 be able to get dropped into this and understand what's going on. So what I want to do is go back
01:49:39.440 to our run controller and uncomment all of these out. Great. We'll restart our application. And
01:49:48.240 what I want to do now is take a look at our collection of things here, and say, let's go
01:49:56.640 ahead and run all of these. I want to run all of these and make sure these are all working. And
01:50:01.440 of course, they are still because, again, we've kind of named everything the same. So I know that
01:50:06.960 my API from my controller level is still working. But now we're talking to a database. So let's go
01:50:12.880 back over to here and go to H2 console. And if we wanted to look at the database here, we can click
01:50:21.360 on run and run, and we see our one run in the system. So this is great. We've gotten one run
01:50:27.920 in there, but I want to be able to get a little bit more data in there. So one thing I'm going to
01:50:33.520 do is actually just come in here and comment this out. And now what I want to do is find a way to
01:50:41.200 kind of batch load some data in just for example purposes, before we move on to having a little
01:50:47.600 bit more fun with, say, like a real database, right? All right. So with this commented out,
01:50:52.800 we're no longer going to be inserting that one record. So if we booted up our application,
01:50:57.600 there would be no records in our app. So one thing I want to do is come back to this command
01:51:03.040 line runner. This is very interesting, right? Because the command line runner is something,
01:51:08.080 and if we jump into it, this is a functional interface that will be run after the application
01:51:14.240 has started. If you're a little bit new to Java, a functional interface is an interface that has a
01:51:20.000 single abstract method. So in this case, that method is run. And because it's a functional
01:51:26.080 interface, it can be used as a lambda expression. A lambda can target this. So you don't need to
01:51:31.920 create a class that implements the command line runner, and then does overrides like the run
01:51:37.280 method. You can use a lambda expression, which we are doing here. So I want to show you this example,
01:51:45.040 and then we'll move on to kind of doing some batch loading. So I have this run here, but I want to
01:51:49.600 save this to the database. This bean annotation, again, is another way of creating a bean in the
01:51:58.400 application context. We looked at things like at component, at REST controller, at repository,
01:52:04.320 at service. These are ways of telling Spring, hey, this is a class that I manage. Go ahead and manage
01:52:11.840 this for me. Bean is another way to create beans and put them into the application context.
01:52:17.760 We're not going to go too far into that in this course, but this is one example of creating a bean.
01:52:23.840 So what we're doing is we're creating a command line runner, and it will get run after the
01:52:28.720 application starts. But because this is a bean, we can say, hey, part of this is, and I need a
01:52:37.440 run repository, go ahead and pass that instance into this bean for me. So now I can say run
01:52:45.440 repository. And there is a create method to pass in a run and create a run from that. So let's say
01:52:54.000 create. Whoops. And then now we should be able to go ahead and run this.
01:52:58.560 And we have an issue here, which is run controller. So let's look at our run repository,
01:53:15.600 create. So insert into
01:53:27.840 script.
01:53:44.240 Fail to execute script. This looks like it's complaining about this. That's okay.
01:53:49.760 Let's go ahead and delete that. And let's run this again. And there we go. The application
01:53:57.040 started up. And if we remember, let's take a look here, we have this thing called the first run.
01:54:03.680 So we should be able to go back to the database here and connect to this. And if we go to run,
01:54:11.680 we have our first run. So good. So we know now that this is a programmatic way that we kind of
01:54:17.200 bootstrap some data. So we're going to use this as a way to insert some data that we can use
01:54:23.760 in our application. But I'm actually going to get rid of this because I'm going to go ahead and do
01:54:28.640 it a different way. So the first thing that I'm going to do is I'm going to create a new folder
01:54:35.200 here called this data. And inside of here, I'm going to say that this is a runs dot JSON. And
01:54:43.440 we have some JSON data that we can paste in here, you can grab this from the repository. And we can
01:54:49.520 say, there we go. So now we have 10 runs. And the reason I did this is so we can basically
01:54:55.520 bootstrap some data, we have some data that we can work with, right? So now I want to talk about
01:55:01.280 maybe how can we read this JSON data, and insert it into the database. Now we already have the
01:55:07.840 mechanism for reading and persisting data, right? We have this create method, we have a delete method,
01:55:15.120 I also have a save all method that can take a list of runs and insert that. So what I'm going
01:55:21.680 to do is create a new file here. And I'm going to call this my run JSON data loader. And in my run
01:55:37.360 JSON loader, I'm going to implement that command liner. Because in this case, I do want a separate
01:55:42.320 class to do this in because I'm going to do a bunch of things. All right, first off, I'm going
01:55:48.160 to get a logger, I have a logger to log some information with. I want to get that log that
01:55:56.240 run repository. So I'm going to say run repository, run repository, and we'll get that through
01:56:04.320 constructor injection. Again, this is dependency injection. When it creates an instance of this
01:56:10.240 class, it will see that it's dependent on the run repository. Spring knows about that class,
01:56:16.000 it'll inject that into this constructor for us. And now we have a run repository that we can use,
01:56:21.760 right? So in this method, now I can say, hey, run repository dot count. So we know this is going
01:56:32.240 to be zero all the time, because we are basically resetting the database when we start. And starting
01:56:39.040 from zero. So we know it's going to be zero. But when we move on to a real database, that's not the
01:56:43.520 case, right? We don't reset a real database all the time. But in this case, it will be zero. But
01:56:48.880 that's okay. We're saying if the count is zero, I want to do some things. I want to go ahead and try
01:56:56.640 and load some data. And wow, copilot on its game today. Let's see if this works.
01:57:03.280 So we need one more thing here, which is an object map. So we need that. That will get passed in for
01:57:15.200 us. This object mapper is equal to object mapper, right? So the reason we need that is we are
01:57:25.920 basically reading in some JSON and trying to map that JSON, deserialize that into objects.
01:57:33.680 And what are we trying to deserialize that into? We're trying to deserialize that into a list
01:57:39.600 of runs. So just like I have run, I'm going to create a quick record. So I'm going to call this
01:57:46.560 my runs. And this will be a record, which is basically just a list of run runs, right?
01:57:57.440 So now I am deserializing that into a list of runs. Run repository all runs. Oh,
01:58:06.640 do we call that something different?
01:58:14.560 So now, again, you don't really need to know this type of code. I just thought it would be nice to
01:58:19.680 show an example of reading some data from a JSON file and inserting it into a database. You could
01:58:25.920 certainly, in the command line runner that was in application.java, insert 10 records on your own
01:58:31.280 and you'd be off and running. I thought this would be a good example. So basically, we're going to
01:58:36.080 read from that file, which is runs.json. If we can, we're going to try and map those to
01:58:42.080 the runs record. We do a little bit of logging here to say how money runs we are loading.
01:58:48.640 And then we save them all. Using that run repository, we're going to persist these
01:58:52.640 off to the database. So let's go ahead and one more thing. This class will never run,
01:58:59.520 because we haven't told Spring about it yet. So we just need to mark it with at component
01:59:04.960 to say, hey, this is something I want you to be aware of. So let's go ahead and run this
01:59:10.640 application. We see reading 10 runs from JSON data and saving it to an in-memory collection.
01:59:18.080 That is probably from some older code, but we'll just say saving it to a database.
01:59:28.000 So this will probably already restarted, but let's do that. And then we can go to
01:59:36.480 the browser. We can reload our database here.
01:59:42.000 And we can say connect. And now we can click run. And now we have 10 runs in the database.
01:59:48.320 And we've loaded those through that JSON file. So cool. We're doing some fun things here.
01:59:54.720 We've connected to a database. That was pretty easy. We're using an in-memory H2 database.
02:00:00.800 We've made some progress replacing our in-memory run repository with a repository that is actually
02:00:08.320 talking to the database. And then we just did some kind of batch operation where we can read
02:00:13.440 from a file and insert into a database. So this has been fun. We're not done yet.
02:00:19.200 Next, what I want to do is kind of replace this in-memory database. This was fun for getting up
02:00:25.760 and running. But let's talk a little bit more about how we can take this one step further.
02:00:30.480 All right. So we've already looked at using an embedded H2 in-memory database. Now I'm going
02:00:35.520 to talk about using something a little bit more production-like, and that is a PostgreSQL database.
02:00:41.280 So from a coding perspective, there's not much change. Now we saw with H2 database,
02:00:46.640 we could simply fire up the application, and we had an in-memory database up and running.
02:00:52.480 With something like PostgreSQL, there's a little bit more, but not much. So I'm going to go ahead
02:00:57.440 and comment out this. And all we would have to do is go ahead and set up a URL, a username,
02:01:04.240 and a password. Now the URL looks something like jdbc colon postgres SQL, something like that.
02:01:15.200 Local is 5432 runners, and then you have a username and a password. If you have a postgres
02:01:20.960 database up and running on your local machine right now, you could do that. Set up a runners
02:01:25.360 database. And then now let's talk about a couple things now. First off, you need a postgres
02:01:33.440 database up and running. So how can we do that? You can download, you can install it, or you can
02:01:38.080 go the route which I'm going to go, which is like the Docker route. Second off, in this schema file,
02:01:44.720 this schema file only gets picked up by embedded databases by default. We are not going to run this
02:01:50.320 automatically when you're using something like Postgres or MySQL. So you have to tell us that,
02:01:55.440 hey, I do want you to go ahead and run that. And the way that you do that is by using the
02:02:00.880 spring.sql.init mode and setting that to always. So that would be good if we have a database up
02:02:07.440 and running on our local machine, which I do not. So you could go ahead and install Docker.
02:02:15.360 So Docker is a way to run a container. A container can be anything from like a database to another
02:02:22.640 application to whatever application we can containerize, right? In this case, it's going
02:02:29.120 to be a Postgres SQL database. This means that I can just run a Docker command and spin up a
02:02:35.440 Postgres database without having to download and configure all, do all the things that we
02:02:41.760 used to do. So you could, you have a couple options here. You can come in here and there is a,
02:02:47.440 if you go to Docker hub and look for a particular container, in this case, Postgres, you can go down.
02:02:52.240 How do you start a Postgres instance? It has the actual Docker run command. You could run this,
02:02:57.920 but then you need to configure your properties and you need to do this every time you start
02:03:02.640 your application up. There's also something called Docker compose, which is a file. In this
02:03:09.680 case, Docker dash compose.yaml that could sit in the root of your project and you can run Docker
02:03:15.280 compose up. It'll look at this, find all the services that it needs to start up and start them
02:03:20.880 up. And this is really handy because imagine a scenario where we had, you know, Docker, Postgres
02:03:27.680 running Kafka, RabbitMQ, some other thing, you know, some other microservice. So this is really
02:03:34.960 nice to be able to like start up services. And in Springlude 3.1, we introduced the Docker compose
02:03:42.080 module, which simplifies a lot of things and we'll talk about those. So when you're over at
02:03:48.800 start.spring.io and you pick a dependency, let's talk like Postgres SQL, right? When you pick the
02:03:55.200 Docker compose module, so we go in here, Docker compose support, it's now going to look at all
02:04:00.640 the other services or dependencies that you've selected. So you've selected Postgres, maybe
02:04:05.920 you've selected Kafka. And what it's going to do, it's going to create a Docker compose file with
02:04:11.520 those services listed. So one way we can look at this is by checking the explorer. And again,
02:04:17.200 I'm going to choose Maven. I'm going to check the explorer and there is a compose.yaml file now.
02:04:24.000 So now this is listing the services based on the dependencies that we've had.
02:04:28.800 So this is really good. So that's the approach that we're going to take today.
02:04:32.720 So I'm going to show you this from the palm.xml. I'm going to copy this Postgres SQL driver and
02:04:40.960 the Docker compose support. So with that, we can head back over to our IDE here. And I'm going to
02:04:47.520 go into my palm.xml. I am going to just delete the H2 database and now bring in the Docker compose
02:04:55.840 support with the Postgres SQL driver. I'm going to go back here and copy the compose.yaml file.
02:05:03.520 So just copy that. And I'm going to create a new file in the root called compose.yaml. Now,
02:05:11.760 if you have other conventions, maybe you put this in a Docker folder and call it Docker compose or
02:05:17.840 whatever you want to call it. You can go ahead and set this up in your properties file. You can change
02:05:23.280 where we're looking for that. By default, we're looking for compose or I believe Docker-compose
02:05:28.800 in the root of the application. So I'm going to post that. Go ahead and set that in there.
02:05:34.480 Now, I want to make a couple changes to this because the first thing is the image. I'm going
02:05:41.840 to leave this how it is, but you may want to change it. So the image is saying, hey, grab whatever the
02:05:46.160 latest Postgres image is. Great for whatever we're doing right here today. But if you're on a team
02:05:52.960 and other people are pulling this down, we want to make sure everybody's on the same version. So
02:05:57.840 you may want to specify a version here. In this case, I'm going to set a database of runners.
02:06:05.280 We'll call this my username. Let's call this password for very secure password. And then
02:06:12.720 we'll go ahead and set this to Dan. So that's the username, password and the database name.
02:06:20.480 Now the port, interesting enough, when you use a Docker compose file and you just specify one port,
02:06:26.800 what that's saying is on my local machine, just use a dynamic port. I don't care which port you're
02:06:32.000 using, but on the container side, I want you to map it to 5432 because that's the port that Postgres
02:06:38.880 is running on in the container. Now this is fine, but in the instance that I want to actually connect
02:06:45.280 to the database, I need to know the port number. Now you could jump through some hoops and run some
02:06:50.560 commands and find out at runtime what port this is using, but I want to be very specific here.
02:06:56.080 So I'm going to say, hey, this is 5432 is going to map to 5432 on my local machine.
02:07:03.040 Now when we use our database tools, we can connect to the database using that port. So
02:07:09.600 with all of this in place, I think what I want to do is just restart the application,
02:07:14.320 see if we have any errors. Oh, and we do because Docker desktop is not running.
02:07:20.560 So let's make sure Docker desktop is running on our local machine to make this work.
02:07:25.040 Again, if you don't have Docker desktop, no big deal. You can go ahead and set up an actual
02:07:29.440 Postgres database and connect to that. That's fine. But now you can see it says using Docker
02:07:35.920 compose file, it sees some services and it goes and went and went ahead and fired those up.
02:07:42.880 So that's up and running. Now we have a database connection to a Postgres SQL database.
02:07:48.800 And we've actually read 10 runs from JSON data and saved it to a database. So let's test that
02:07:56.240 out before we had the H2 council. Now, how can we go ahead and look at our database?
02:08:00.160 If you're not using IntelliJ Ultimate, don't worry. There are plenty of free grade tools
02:08:04.480 out there to connect to database and manage them on Mac and Windows, Linux, etc. So go ahead and
02:08:10.560 find something like that. If you're in IntelliJ Ultimate, you can just click this database icon,
02:08:15.920 you can go here and say, I want to add a new database. And I'm going to say this is Postgres.
02:08:21.360 And this is on localhost. Again, 5432. That's the important part. The username was Dan.
02:08:26.960 The password was password. The database was runners. And that looks good. So now that's the
02:08:37.760 JDBC URL, the connection string that we need to connect to the database.
02:08:42.560 Let's see if this works. We'll go ahead and say, OK, come in here. We see that there is a table.
02:08:49.840 There is a run table. And we see that we have our 10 runs in there. So this is really great to see.
02:08:57.520 So we have our connection to our database. Now, I want you to notice something here because
02:09:03.520 we've declared some properties in here. But I don't have any of those properties set up here
02:09:09.920 in my application, not properties. That is because we don't want you to have to
02:09:14.960 duplicate these properties, right? We have a database. We have a username. We have a password.
02:09:19.680 We have a port. We don't need to duplicate these across both files. What happens is Spring uses
02:09:26.720 something called the connection details interface behind the scenes. And there are some implementations
02:09:31.520 of this, one of which is being able to create a JDBC connection. And it will read this at runtime
02:09:37.680 and fill in those properties and put them into a property source at runtime for you. So it knows
02:09:42.560 how to construct a JDBC URL. It knows how to get the username and password, et cetera. So that's
02:09:48.000 really nice that we don't have to kind of duplicate those properties. So that is Docker Compose.
02:09:55.680 Let's talk about one more kind of abstraction at the database level. OK, we're back over here at
02:10:03.680 Spring.io. If we go to projects and you go down to Spring Data, this is a really cool project made
02:10:10.240 up of and has many, many modules underneath of it. You see here it says Spring Data's mission is to
02:10:15.440 provide a familiar and consistent spring-based programming model for data access while still
02:10:21.760 retaining the special traits of the underlying data store. So we know that different data stores,
02:10:26.240 different databases have special traits. We kind of keep those underneath the hood and we're allowed
02:10:33.120 to use some of those special things that different data stores can do. You'll see that there are some
02:10:38.160 features here. So powerful repository and custom object mapping abstractions. This really allows
02:10:46.640 us to define an interface in Spring Data and have it get turned into an implementation at runtime.
02:10:52.560 What this means for you is that you don't have to write all of these CRUD methods out. We saw
02:10:58.160 the JDBC client. I really like the JDBC client. It's nice. It's fluent. It's easy to read,
02:11:04.160 but I still got to write all that code to get just some simple CRUD things going on, right?
02:11:09.440 Maybe I want an MVP. Maybe I want to kick something up real fast. I don't want to have to do that for
02:11:13.600 every resource in my application. So Spring Data allows us to kind of bypass some of that and do
02:11:18.960 it for us. Then when you have special needs like, hey, I got to find all the runs by location,
02:11:26.560 then you can write these dynamic query derivations from the repository's method name. So you can just
02:11:32.240 write, return to me a list of runs, and we're going to call this method find by run, find by
02:11:38.560 location, and pass a location in, right? So this is really cool. Spring Data has a lot of really
02:11:44.320 powerful concepts. Now two of the most popular Spring Data projects out there are Spring Data JPA,
02:11:51.440 which is an implementation of the JPA specification, the Java persistence abstraction.
02:11:57.520 And this underneath the hood by default uses Hibernate. So you might have heard of an ORM
02:12:03.280 or Hibernate before. That's what Spring Data JPA is doing. Spring Data JDBC actually simplifies
02:12:10.080 a bunch of things by kind of getting rid of some of the things that Hibernate does,
02:12:15.200 and really just allows you to model your domain objects and use kind of straight SQL that we're
02:12:23.360 used to writing. And it still gives you the power of repositories, dynamic query derivation, and so
02:12:29.440 on. So we're not going to spend a lot of time on this today. We could really create a whole course
02:12:36.960 on Spring Data and some of the other implementations. In fact, you could create a whole
02:12:40.800 course on just like Spring Data JDBC, right? So what I'm doing here today is I'm just showing
02:12:46.480 you this as an option so that once you get past like the JDBC client and some of the basic stuffs,
02:12:54.320 you know that this is available to you. And you'll probably come across code out there
02:12:59.920 that's written using Spring Data. And so I just want you to be aware of it as you're getting into
02:13:05.920 it. So from start.spring.io, you would pick something like Spring Data JDBC. You would pick
02:13:14.160 your database, in this case Postgres. We would pick the Docker Compose support. So if I go look
02:13:19.200 at Explore, again, I'll come back and choose Maven. If I look at Explore here, the starter for this
02:13:26.080 is Spring Boot Starter Data JDBC. So I'm going to go ahead and copy that. I'm going to head back
02:13:33.360 to the IDE. We're going to go over to our palm.xml. And I am going to just put this right here.
02:13:42.560 And we're going to reload Maven. And I'm going to actually stop this for now. And so now we're
02:13:47.600 going to talk about like what does this do for us? So let's go ahead and look at run and look at our
02:13:53.520 run repository. So right now this run repository has like all this code in here that we wrote
02:14:00.080 using the JDBC client. So I'm going to actually rename this. So let's say rename
02:14:07.040 room JDBC client.
02:14:16.480 Sorry, my shift key has been sticking on me lately. I got to fix that. So JDBC client run repository.
02:14:23.840 That's going to break some other things, but that's OK. We'll fix that now. So what I'm going
02:14:27.680 to do is create a new one. We're going to call this run repository. But this is going to be an
02:14:37.920 interface, not a class interface. How is this going to work? All right. So let's go ahead.
02:14:43.840 We can extend some of the repositories that Spring Data gives us because it's a CRUD repository.
02:14:50.560 For JP, there's a JPA repository. There's also a list CRUD repository. Now the arguments that
02:14:58.080 it's taking here is the type and then the ID of that type. So we're creating a repository around
02:15:06.000 the run type. So we have a run already if we had like a user, if we had
02:15:13.520 equipment, right? Like we could create repositories around all these different types.
02:15:18.320 So the ID type of a run is the integer, right? So now that we have that, that's one piece of the
02:15:26.720 puzzle. The other piece is we have to come into run and we have to mark the integer. We have to say,
02:15:32.400 hey, this particular thing is the ID of our type. So we're saying this is the ID. I'm going to do
02:15:41.040 one more thing. And this is kind of specific to Spring Data JDBC. And that is there is an
02:15:47.280 at version column. And we'll call this integer version. And this is just a way to track whether
02:15:54.560 this is a new type, a new row or an existing row to keep it simple. All right. So with that,
02:16:02.080 I need to make one more change. And that is to the schema. And I got to go ahead and say that
02:16:06.960 I need a version. And this is an int. It can be null. So that's okay. Yeah, so that looks good.
02:16:15.440 So now with all of those in place, I haven't done anything. Let's look at this list CRUD repository
02:16:20.720 real quick. So first off, there's a save all method that will return a list of types, right?
02:16:27.920 There's a find all, which will return a list of those. And then there's a find all by ID.
02:16:33.760 We can also see there's a CRUD repository. So we can save, save all, find by ID, exists, find all,
02:16:41.440 find all, count, delete, delete, delete, delete, delete, right? So all of these methods are
02:16:47.760 available to us out of the box based on that type. And we don't have to write any of that code,
02:16:52.799 which is really nice. So what this tells me now is if I look at my run controller,
02:16:58.240 I'm pulling in that. Okay, so this refactored it. Let's go back to the run repository and see if
02:17:06.480 that breaks anything. So yes, so this needs to be a run repository. So that looks good.
02:17:15.360 So now our create method, we may need to call save instead of create. This is save. And this
02:17:24.799 actually doesn't take in the. Right. And then the delete doesn't delete.
02:17:42.639 So now the delete method doesn't take an ID, it actually takes the run to delete.
02:17:55.280 So all I'm going to do is use the run repositories that find by ID, and then pass the ID in there.
02:18:03.360 And we'll say get, we could do, there's another one, we could do this a little bit safer, but
02:18:08.480 this is okay for now. So now my controller is basically lined up with the new run repository
02:18:15.200 that is using Spring Data. Again, we haven't written any logic here. Let's go ahead and see
02:18:20.719 if we can restart our application. So again, looking at that compose.yaml file. All right,
02:18:30.559 now something interesting happened here. Says not loading runs from JSON data because the collection
02:18:37.280 contains data already. Remember, we had in our JSON loader, we had this, hey, if the run repository
02:18:44.400 dot count, now the run repository dot count method is using the new repository that uses Spring Data,
02:18:50.719 there's a count method in there. So it'll count how many rows there is. Is there zero rows? If
02:18:55.280 there's zero rows, go ahead and read from the JSON and save those. If not, hey, we've already
02:19:01.520 got rows in there. Because remember, now we're using Postgres. This is not resetting every single
02:19:06.400 time that we restart the application. So if we were to go into our database again,
02:19:10.959 look at our table, we'd still see our 10 runs, right? So that's interesting. The other part is,
02:19:17.760 yeah, if we go to the terminal, and let's just clear this and HTTP IE, so 8080 slash API slash runs.
02:19:29.760 Oh, we got a little error. Prepared statement has a bad SQL grammar.
02:19:44.000 That's okay. We like errors. Let me look over here.
02:19:48.559 This is a little bit hard to read. So let's find out what's going on here.
02:19:59.760 Okay, so bad SQL grammar, select run,
02:20:14.880 column run dot version does not exist. Okay, so what happened is,
02:20:22.000 probably the schema didn't get rewritten that second time when we added version.
02:20:25.920 So let's just go ahead and come to this database. And I'm going to drop this table.
02:20:36.720 Right. So now if we restart the application, it should see that that table doesn't exist,
02:20:42.320 and go ahead and add it. And now it added those 10 there. So now let's go ahead and refresh this
02:20:49.760 and make sure that it has the version, which is null. Okay. Right. So now that looks like it's
02:20:58.480 working. Let's go ahead and check our terminal again, and go to 8080. There we go. Now we have
02:21:05.040 our 10 runs in the system. So cool. I want to show you one more thing with Spring Data. Again,
02:21:11.200 I just love geeking out over this stuff. So one of the things that we've done is add all of this
02:21:16.480 like custom or crud functionality. But what if we wanted to add some custom functionality?
02:21:21.840 What if we wanted to say, hey, give me a list of runs, and I want you to find all by location,
02:21:32.960 and then pass in the location that you want to find all by. Next, this is not find
02:21:39.520 all by. And then as you can see, we also get IntelliSense. This is based on the type that
02:21:46.560 we're working with. So you could find all by completed on, completed on after, and you could
02:21:52.320 start to chain these together. You could say, find me all by location and by miles, greater than.
02:22:00.240 So I want to find all my outdoor runs greater than five miles. You can do that. You can start
02:22:04.640 to chain all these together. Now I will say once you get into like, if you start chaining three or
02:22:10.160 four or five or six different things, there's probably some better ways that we can do it.
02:22:14.160 But that's OK. So I'm going to say find all by location, and I'm going to pass in the string
02:22:20.320 location. And then I could just go into my controller and create a custom method for this.
02:22:27.280 So I could say, yeah, that looks good. Get mapping. And I can say, list of run find by location,
02:22:36.640 path variable, string location, return find all by location. That looks pretty good. Let's see if
02:22:44.400 we can restart our application and do that. So now what I would do is go to
02:22:49.360 this slash location slash outdoor. Right. And now it finds all of the outdoor runs. So is there
02:23:02.240 no indoor runs? Let's see. Oh, there's a few. Oh, yeah. OK. So OK. I was looking at something
02:23:12.320 different. I thought it was the 10 showing me the 10 of them. But yeah. So that was a quick way to
02:23:17.520 write a custom query. You can also come in here and add the at query annotation. So if you wanted
02:23:25.360 to write your own query here, you could do that as well. So there are a bunch of ways that you can
02:23:30.240 add functionality on top of this repository that gave you all this CRUD functionality out of the
02:23:35.360 box. So I think that's where we're going to wrap up our database section. I hope you learned a lot
02:23:41.280 in the section. We started off by kind of replacing our in-memory collection with an H2
02:23:47.040 embedded database. We talked about connection strings and all those things. We talked about
02:23:53.520 how to use the JDBC client to get data in and out of our H2 database. And then we moved on and we
02:24:00.720 replaced our H2 database with a Postgres SQL database using Docker, using a Docker Compose
02:24:06.480 support in Spring Boot 3.1. And we finished it up by taking a look at Spring Data. So I hope
02:24:12.560 you learned a lot in this section. I had a lot of fun. But with that, it's time to move on to
02:24:18.160 the next module. In this module, I want to take a look at REST clients. Now, we built out our
02:24:24.800 REST API and we've talked to a database to get some data. But what you'll find is often in
02:24:31.520 organizations, in applications, they're not just standalone applications,
02:24:36.240 huge monolithic applications. Sometimes we're dealing with microservices where
02:24:40.960 this particular application is dealing with one thing and maybe to get data about say a user,
02:24:47.600 it has to reach out to another service in the organization. The question is, how do you talk
02:24:53.040 to that other service? One such way is by using a REST client. So here we're in the Spring
02:24:59.040 documentation. You can see the Spring framework provide the following choices for making calls
02:25:03.920 to REST endpoints. Now, I'll give you just a really quick history lesson so you understand why
02:25:09.360 there's some options here. So when Spring MVC first came about, the REST template was born.
02:25:16.560 And the REST template was a way to make a client call to another service. The REST template over
02:25:22.000 time had issues come up and, hey, I need to be able to do this in this sort of way. So over time,
02:25:30.000 that API grew into the API that it is today. So there are a lot of overloaded methods in the REST
02:25:37.120 template. Well, when Spring Web Flux came along, which is the reactive stack for building web
02:25:43.920 applications or web APIs, they decided to take a look at the client and kind of start from the
02:25:50.320 ground up. So they built the web client. So the web client is used strictly in the reactive world,
02:25:58.320 but you could use it in Spring MVC apps before because it had a blocking call. So you could say,
02:26:03.760 hey, do this, but this is going to be a blocking call. So the web client was really great. Folks
02:26:09.760 really loved it because it had this nice, fluent API. It was easy to understand. There wasn't all
02:26:14.480 these overloaded methods. And so we found that a lot of developers were bringing in the web client
02:26:20.960 into their Spring MVC apps. So from that, the REST client was born. And the REST client
02:26:27.840 is a blocking, synchronous client with this nice, fluent API. Really easy to use. And so that's what
02:26:36.560 we're going to do today. We're going to take a look at the REST client, and then we're also going to
02:26:39.760 take a look at HTTP interfaces. This is a really nice feature that allows you to talk to another
02:26:46.640 service by just defining an interface and not having to write the low-level implementation
02:26:53.840 to talk to another service. We saw an example of this in the last module with Spring Data.
02:26:59.200 I need some crud functionality, but I don't want to write all of it. Just define an interface and
02:27:04.400 let Spring turn it into an implementation at runtime. HTTP interfaces is analogous to that.
02:27:10.720 So let's have some fun here. Now, we don't need to do anything as far as adding more dependencies
02:27:16.800 because with the Spring Web dependency that we chose at the beginning of this course,
02:27:21.600 that will bring in the REST client. And so we have everything we need. So now all we need is
02:27:26.160 another service to talk to. So I fumbled around with this and thought about some different scenarios
02:27:32.160 that we can go through. We could have created another application to do something, maybe to
02:27:37.840 bring in a list of locations or something. But I thought I'd just go a little bit off the path
02:27:43.920 of the runner's application and just use kind of a public API. That way, you don't need another
02:27:49.680 service. This is a public API that anybody can talk to, and you don't need to authenticate against it
02:27:55.440 or anything. So this service is called JSON placeholder service. And again, you can go out
02:28:00.960 and test this on your own. You can see you can go try it. Hey, I want to talk to to-dos. I want to
02:28:07.280 get a specific to-do. You can get it and it will give you back a to-do. Now, there are a bunch of
02:28:13.600 different resources here. So I've done stuff with all these different endpoints before, but the one
02:28:17.840 we're going to work with today is users. So we're going to set up. We already set up a user package
02:28:22.800 earlier. In the user package, this is where we're going to define all of the code we need to talk to
02:28:28.560 this service and bring us a list of users. If you want to keep it in the realm of this runner's
02:28:33.920 application, let's just pretend that we have a bunch of users that need to log in, and maybe we
02:28:38.000 get those users from another service, and this is that service. So here is what a specific runner
02:28:45.280 looks like, a single runner looks like. I'm going to copy this because what we want to do on the
02:28:50.080 Spring side is model a type after this. We're going to create a record based on a user, and it's going
02:28:56.640 to have a couple things, right? It's going to have some fields, but it also has other types,
02:29:00.960 like an address. An address has a geo. We also have a company. So we need to model this out on
02:29:05.840 the Spring side so that when we call this service, we can say, hey, what I expect back is a user,
02:29:12.000 and all these fields will kind of line up. So I'm going to copy that. I'm going to go back to
02:29:16.480 IntelliJ. In a user package, I'm going to create a new Java class. We're going to call this user,
02:29:22.960 and this is going to be a record. And then let's just put this on different lines. And now
02:29:30.640 Copilot, again, is on its game because I've done this one before. So it's remembering this. So
02:29:35.520 let's just go ahead and paste. I'm also going to paste this up here just so we can kind of see,
02:29:39.760 oh, let's put that in a comment, Dan. And let's put that there. So now we have ID, name, username,
02:29:48.800 email. Address is its own type, which is going to contain geo, string, phone, website, and then
02:29:57.360 company. So now what we need to do is create an address. So let's create an address record.
02:30:04.080 So I'm going to go ahead and do that. And let's put this on separate lines, and it's going to
02:30:09.200 figure that out as well. So let's, I don't know why I keep hitting the wrong button today.
02:30:14.800 Create record geo. And then what is geo going to have? It is going to have a lat and a long.
02:30:21.440 All right. I think there's one more we need to create, which is going to be the company.
02:30:27.440 And so let's create a company record. And this has a few fields, name, catchphrase, and yes.
02:30:36.320 And then we go. So now we have something in our system that we can model after a user. So when
02:30:42.640 we call out to that system, that public API, we could say, hey, give me back a list of users
02:30:49.280 or give me a single user, right? So I'm going to create a new Java class here. We're going to call
02:31:02.720 this the user rest client. We're going to call this the user rest client.
02:31:19.440 And this is going to be a class. And we need to mark this with something. So I'm going to mark
02:31:24.960 this with a component, just because if we want to go ahead and use this later, we want to tell
02:31:30.080 spring hey, manage this class force, put an instance of this into the application context.
02:31:36.000 So what we need is a rest client. So I'm going to say private final rest client. And we'll call
02:31:43.280 this rest client. All right. So we've declared this rest client. But how can we get an instance of it?
02:31:47.920 Let's take a look at rest client. And we notice right away that it's an interface. So we're not
02:31:52.240 going to be creating a new instance of the rest client. But if we drill down into this, there are
02:31:57.920 some static factory methods which we can use. So we can create a new rest client. We can also create
02:32:03.440 a new rest client with a base URL. We can also create one from a rest template. So if you have
02:32:09.120 a rest template instance, you can create a new rest client from that. And then there are these
02:32:15.200 builder methods. And builder is actually an interface in here as well. If we look at builder,
02:32:21.280 there is a default rest client builder that implements that rest client builder. And this
02:32:27.520 is something that will get created by Spring Boot. So we'll have an instance of this default
02:32:32.880 rest client builder if we just ask for an instance of the rest client builder. In here, you'll see
02:32:39.600 that it declares a bunch of things, these private static final Boolean for like the JDK client,
02:32:47.120 the JD client, the HTTP components client. We'll talk more about that in a second. So if you want,
02:32:54.320 you can dig into that and see what the default rest client builder is. This means that we can
02:32:58.960 come down here and we can create a new constructor. So we can say public user rest client. And we can
02:33:06.800 get an instance of that builder. So we can say rest client builder. And it will basically pass in that
02:33:14.480 default rest client builder. So now we have a builder, co-pilot. Yes, thank you. So we're using
02:33:20.240 the builder to set the base URL. So the base URL is the JSON placeholder service. So if we go back
02:33:27.920 to the browser, you'll see, this is going to be the base URL, this slash users will be the the URI
02:33:34.800 for all the users. And then if you wanted to get like a specific user, you could say slash users
02:33:39.840 slash one. Alright, so now that we have kind of our rest client ready to go, we can start to write
02:33:46.160 some methods to interact with this service. So I want a an instance where I can get a list
02:33:53.520 of users. So I want all the users, I might call this find all. And I'm going to return whatever
02:33:59.920 the rest client dot and now this is for me one of the big advantages of the rest client over
02:34:06.160 something like the rest template that had all these overloaded methods. When I hit rest client
02:34:10.960 dot, I'm given some options here. It's not a whole lot of overloaded methods. These are the request
02:34:16.720 methods. I know that, hey, I want to perform a get a put a delete a post, etc. So I know I'm going
02:34:23.280 to perform a get here. The URI off the base URL is going to be that slash users that we saw before.
02:34:31.600 Next, I need I basically have two options here. I can use retrieve or exchange. Now retrieve is
02:34:38.080 kind of the simplified version of this where exchange allows you to get a little bit more
02:34:42.720 control over the request and the response. So I'm going to say retrieve. And then finally,
02:34:48.560 hey, what do you want us to do with the response in this case, the response body? In this case,
02:34:54.480 I want to just turn it into a parameterized typed reference. And this is a way that we can get a list
02:35:00.000 of things. So that will give us a list of users. How can we ask for a single user? So I may just
02:35:07.200 want to get a user. I may call this fine by ID. I'll get an integer ID. Then I'm going to use the
02:35:15.600 REST client dot get. I'm going to use a URI of slash users slash dynamic ID. And we're going to
02:35:26.400 replace that with whatever we get as an argument to this method. So now we have a URI there. Next,
02:35:33.280 we're going to retrieve. And finally, we're going to turn this into a body of what type,
02:35:38.240 we're going to model it after that user record that we created. So great, we have two methods here
02:35:44.240 that allow us to basically find all the users and find a specific user when we're talking to
02:35:50.560 that other service. So normally, I would write a test against this, we're not going to get into
02:35:55.680 tests until the next module. So right now, just find a quick way to test this out using the
02:36:00.560 command line runner. So what I want to do is get an instance of that client. Let's just go double
02:36:07.040 check that we marked it with a component and we did. So now we know that we can get an instance
02:36:12.720 of this here, because it's in the application context. And let's just make this simple,
02:36:18.240 let's call this client. And in here, I can say, client dot find all that is going to return a
02:36:24.640 list of users, we'll call that users, and I'll just sis out users, and we should be able to run
02:36:30.240 this now. And let's see. And there are all the users that we pulled down from that JSON placeholder
02:36:39.040 service. If we wanted to get a specific user, we could say client dot find by ID, we know there's
02:36:45.840 one in there with one, so I could say dot bar, we'll call this user, and then I can just sis out
02:36:52.400 a user. And we can go ahead and run that. And again, because that's a record, we get that two
02:36:58.320 string component in there. So we have that single user we're splitting out. Based on that two string,
02:37:04.160 we're able to view a representation of that user. So good. That was pretty easy, right? I like the
02:37:12.800 REST client, I like this simple, fluent API that isn't complicated. Again, I just I can read this,
02:37:21.120 I can look at this and like know what's going on. I want to look at a couple other options that you
02:37:26.720 can talk about when you're using the REST client. And then we'll move on to HTTP interfaces. So
02:37:33.680 what is happening underneath the hood, this is actually the API, this isn't the low level
02:37:38.320 mechanism that is actually making that API call across HTTP, right? For that, there are a bunch
02:37:46.640 of different options that you have. There is a default HTTP client underneath the hood, but you
02:37:51.440 can always swap that out for something else. And you can do that using the request factory. So we'll
02:37:56.800 look at the request factory. It takes in a client HTTP request factory. We'll see this as an interface.
02:38:03.440 If we look at the implementations of this, there are a bunch of them. So if we wanted to use something
02:38:07.920 like the JDK client HTTP, we could use that from JDK 11. If we wanted to use something like Jetty,
02:38:15.440 or something from the Apache Commons, we can swap these out. So all we have to do is say new JDK
02:38:23.680 HTTP request factory. And now I'm using a different HTTP client library underneath the hood. I could
02:38:30.320 also extract this out to a variable. So if I wanted to, I can say new JDK HTTP request factory,
02:38:40.240 let's set a var there. And now what I could do is I can customize the underlying HTTP client.
02:38:47.200 So if I wanted to do something like set the connection timeout, I don't think that's an
02:38:52.560 actual call. I think it's set read. So we have set read timeout, set read timeout with a duration.
02:39:02.160 So we can kind of change this if we wanted to. We could say I want the timeout to be this instead.
02:39:07.680 So this is a way to get at the underlying HTTP request factory and go ahead and customize it.
02:39:15.200 And then I would just pass in this variable here. So that's one thing we can kind of customize.
02:39:22.480 Another thing we can customize is if we go in here and say
02:39:29.040 dot, we see that we can do something like a default header. Maybe we wanted to pass a user
02:39:34.320 agent and say what the value is. We can set a default header here. So any call that goes out to
02:39:39.440 the JSON placeholder service, we'll go ahead and pass this header along with it. Some other things
02:39:45.120 we can do is by setting a request interceptor. So an interceptor will allow you to intercept that
02:39:51.840 request, you can do it in line. So we can see if we look at this, this is based on the interface
02:39:58.000 client HTTP request interceptor. This is a functional interface, you can pass a lambda
02:40:03.040 there if you just have something simple to do. If not, you can implement this interceptor.
02:40:09.200 And it allows you to get access to the request and you can kind of handle do some more things
02:40:14.320 with that if you want. A couple of examples of this and I've done some of these, I think on the
02:40:19.200 YouTube channel is what if you had to do like an OAuth 2 handshake and you wanted to go out and
02:40:24.880 get a JSON web toga JWT and pass that in every request. You can do that there. Maybe you wanted,
02:40:31.200 there's a really great project by a co-worker of mine for retries. So if you wanted to call this
02:40:37.360 service, but whatever reason it failed once failed twice, I want to retry this service three times.
02:40:43.200 These are all like custom things that you might want to do, but you can do them in an interceptor.
02:40:48.960 So that is some other things that you can do. So we've looked at the user REST client. This is
02:40:56.480 really great, but again, I'm writing some code here. What if I don't want to write code? And we
02:41:01.120 saw this already in the Spring Data example where we can declare an interface, have Spring turn this
02:41:06.400 into an implementation at runtime, and handle some of this for us. So that's what we're going
02:41:12.080 to take a look at now. And we're going to do that by creating a new Java class. And we'll call this
02:41:17.840 the user HTTP client. And this is actually going to be an interface. So let's say interface.
02:41:26.000 And then all we're going to do in here is write out the contracts for the methods that we want.
02:41:30.640 This is going to look pretty similar to this. We want a list of users, find all, we want a user
02:41:37.760 find by ID. So let's go ahead and put those in here. So I'll say list of user. And this is called
02:41:44.560 find all. And again, all we're doing is creating the contract. And in this case, user find by ID,
02:41:51.360 and we'll actually get this through a path variable. Now we need to kind of hook these up
02:41:55.440 and say these are going to be, we have to give them an annotation to say, hey, like this is
02:42:01.200 something I want you to make an exchange with another service for. And the way that we do that
02:42:06.560 is there is the HTTP exchange annotation. But there are also specialized versions of this. So
02:42:12.720 this is a git exchange. So I'm going to use the git exchange annotation. And then you're going
02:42:19.040 to use the URI. So remember with the REST client, we'll set a base URL. And this is the URI. So for
02:42:25.760 this one, we'll say git exchange. That almost looks good. Let's say users slash ID. And now
02:42:33.120 this is all we have to write in this class. We don't have to write out all of this boilerplate.
02:42:38.240 Now there is one boilerplate thing we'll have to do. And this is basically setting up that REST
02:42:44.880 client and telling Spring, hey, this is a user HTTP client. And I need you to go ahead and create
02:42:54.640 this for me. So the way that we do this is user, actually user HTTP client, user HTTP client.
02:43:03.040 We're going to use that REST client to, oh, yes, the code pilots on its game. So really what we're
02:43:11.200 doing here is we're creating a REST client using one of those static factory methods. We're setting
02:43:15.040 the base URL. We're creating an HTTP service proxy factory with that REST client. And then we're just
02:43:21.840 creating a client and we're returning this user HTTP client. Now again, this is a little bit of
02:43:27.600 boilerplate. I usually have like a live template here in IntelliJ that creates these for me,
02:43:34.080 or a co-pilot. If you've done it enough, it will go ahead and write it for you.
02:43:38.480 Once this is in place, this creates a bean. This is now a bean in the application context.
02:43:44.320 So I now have access to that. So really, all I got to do here is switch this out for the user
02:43:50.320 HTTP client. Because I've named those the same, this should just work. But again, we haven't
02:43:57.440 actually written any code to talk to that service. This is being done for us by Spring at runtime.
02:44:04.800 So pretty cool stuff with HTTP interfaces. Now again, this in Spring Boot, in the latest version
02:44:11.280 of Spring Boot 3.2, this is using the REST client underneath the hood. We can see that here. We're
02:44:16.800 using REST client. In previous versions, if you're on something like 3.0, you would have to bring in
02:44:22.960 the web client to make this work. But now this just kind of all works seamlessly in the MVC stack.
02:44:29.440 So pretty cool stuff. I hope you got something out of this. We talked about a little bit of the
02:44:35.760 origins of REST clients in the Spring world, how we've gotten to the REST client in 3.2,
02:44:42.320 HTTP interfaces, to kind of simplify and take away some of that mundane boilerplate code that
02:44:48.880 we have to write. So with that, I think we'll end this section and we'll get ready to start writing
02:44:55.280 some tests. I will write some tests against this and a whole bunch of other code that we've written
02:44:59.840 here in this course. So with that, let's move on to the next module and talk about testing.
02:45:05.840 In this module, I want to cover testing. Now I talked about this early on in this course.
02:45:10.960 This probably isn't the route that I would go if I was building an application today. I would write
02:45:15.680 a class and I would write a test for it. But I didn't want to bog you down with the mechanics
02:45:20.240 of writing a test. So I went through and we built out an application. We built the REST API.
02:45:25.600 We talked about talking to a database. We talked about being able to communicate with other services
02:45:30.720 via the REST client. So now I want to kind of step back and talk about testing and specifically
02:45:36.400 testing in Spring Boot. One of the things I love about testing in Spring is that there is no need
02:45:43.200 for you to opt into testing. We've already done it for you. So we are giving you all the tools
02:45:48.240 you need to write your tests. And there are a whole bunch of tools available to you right out
02:45:52.880 of the box. And I want to start there. So if we're on the Spring Initializer and we don't pick any
02:45:57.680 dependencies, we go ahead and check Maven and click this Explore button. You see down here,
02:46:03.920 we have this dependency for Spring Boot Starter Test. Now Spring Boot Starter Test is made up of
02:46:10.800 a bunch of dependencies. It gives you a bunch of tools out of the box. The nice thing is this
02:46:15.760 scope is in the test scope. This means that these dependencies are loaded when we're using tests.
02:46:22.720 But when we build our artifact for production, then all of this kind of gets stripped out. So
02:46:27.920 we're not asking you to bundle a whole bunch of libraries in there when you're not going to use
02:46:32.480 it for production. This is strictly for testing. And there is a bunch of stuff that comes with it.
02:46:38.400 And we'll go through some of that. So the first thing I want to look at is in your test package
02:46:43.120 under Java, there is a single test. In this case, it's called runner's applications test.
02:46:49.760 We could even rename this because I renamed the application. So I can rename this to application
02:46:56.240 tests and refactor that. And there's a single test in here called context loads. There's no
02:47:02.400 code in there, just a context loads. Now we can run our tests via the IDE. There's also
02:47:10.640 a Maven plugin to do that. So I'm going to do this right from the IDE. You can say run application.
02:47:17.360 And this will run the application tests. And if we look in here, we see fail to load,
02:47:22.720 something has happened. And I think, and this is because of some of the things that we're doing
02:47:29.600 with the database connection. I haven't refactored this to make this work out. But what this will
02:47:34.400 do is it will basically fail if some exception is thrown and something's happening now
02:47:40.320 with that. Basically, the database and the test environment isn't configured.
02:47:44.080 But if you download a project from start.spring.io, you create this new project and you have the
02:47:48.720 single test in there, this will work right away. And so this is a test that I would often keep in
02:47:53.920 here. I get a lot of questions like, should I delete this? No, keep this test. This is a
02:47:57.520 good sanity check. The context loads means, can I just get an application up and running?
02:48:02.720 And from this standpoint, I can't because I have some things going on with the database connection.
02:48:07.200 But most of the time, this will just kind of give you a sanity check. So this is a good place to
02:48:11.680 start. This is my main test. And this is going to kind of stay there and give me that sanity check.
02:48:19.120 Now there's another annotation in here at Spring Boot tests. I'm going to download the docs for
02:48:23.920 that. And this is one you're going to come across often. This annotation that can be specified on
02:48:28.960 a test class that runs Spring Boot-based tests provides the following features over and above
02:48:35.200 the regular Spring Test context framework. So it does a whole bunch of other things. It allows you
02:48:41.280 to set a context loader. It allows for custom environment properties. So you could pass in
02:48:47.360 properties to override something. In this case, the data source, right? We could maybe switch
02:48:52.480 back to an H2 for a test. I wouldn't do that, but just an example of something we can do there.
02:48:59.280 Provide support for different web environment modes. So you can basically start a fully running
02:49:05.840 web server or start some kind of mock web server that could be on a defined port or random port.
02:49:11.760 Doesn't matter. So this is nice. The Spring Boot test, it's kind of like the kitchen sink for
02:49:16.080 being able to test different things in spring. Also does things like register a REST template,
02:49:22.400 test REST template, or a web test client being for web tests that are useful using a fully
02:49:28.960 running web server. So I need to talk to like some other service, right? So this is the Spring Boot
02:49:35.520 test annotation. You'll come across this often. Next, I want to go ahead and look at some
02:49:41.280 documentation. So I'm going to go over to spring.io. We're going to go into project. We're going to go
02:49:46.080 to spring boot. And under the learn section, we'll go to the reference docs. And in here,
02:49:52.080 this is kind of broken up into different sections. If you look under core features, we see profiles,
02:49:58.000 logging, testing and more. So this is where I want to be. So I can go into core features and go down
02:50:04.400 to testing. And this is where I kind of want to start. So spring boot provides a number of utilities
02:50:09.600 and annotations to help when writing or testing your applications. Test support is provided by
02:50:15.200 two modules. The spring boot test contains core items. The spring boot test auto configure
02:50:20.880 supports auto configuration test. Most developers just use that spring boot starter test, that
02:50:26.400 starter that we saw that got included, which imports both spring boot test modules as well as
02:50:31.920 JUnit, JUnit and Jupyter to be specific, that's JUnit 5, AssertJ, Hamcrest, and a number of
02:50:39.760 useful libraries. By default, we're using JUnit 5 now not JUnit 4. So if you need to use JUnit 4,
02:50:48.080 there's a way but we're using JUnit 5. So here's what I wanted to talk about. These are the number
02:50:54.640 of dependencies, the tools that you have at your disposal. I think part of the key is, you know,
02:51:01.360 we've talked about it, spring's been around 20 years, spring boots been around 10 years.
02:51:05.120 If you go search for something, and you say how to write a controller test,
02:51:08.800 like you may get all these different examples. And you're like, what are all these things in
02:51:14.000 this test? I don't understand what these things are. And part of that is understanding what things
02:51:19.120 are available to you out of the box, what libraries, right? So JUnit, the de facto standard for unit
02:51:25.040 testing job applications. This is how we write our tests, how we there's a test runner, how we can run
02:51:30.640 our tests. The test annotation comes from JUnit. JUnit also comes with some assertions. So I want
02:51:38.320 to do this thing and then assert that this particular thing equals some value that we
02:51:43.920 expected to write. So that's JUnit. Spring tests is kind of the core testing utilities, the integration
02:51:50.640 test support for spring boot applications. Assert J is another way to use assertions,
02:51:57.120 it's just a different way of using them as this nice fluent library. So you can use the ones that
02:52:03.200 are in JUnit. You can switch over to Assert J, which I know is very popular. I wouldn't recommend
02:52:10.000 mixing and matching both because you kind of want to just stick with one style, right?
02:52:14.800 Hamcrest is another way to go ahead and match on things, also known as constraints or predicates.
02:52:22.400 So those are the kind of core things. And we get into Makito. So Makito is, hey, we want to mock
02:52:28.320 something out. So in the example of our controller that uses that repository that talks to a database,
02:52:35.840 when I want to test the controller, all I care about is the controller. I don't really care about
02:52:40.400 other dependencies. I don't care about talking to a database, talking to another service,
02:52:46.400 fetching data from some event-driven architecture. I don't care about those things. I want to mock
02:52:52.160 those out so that I'm only focused in on the controller. And Makito is, again, the de facto
02:52:58.800 standard when it comes to mocking in the Java universe. Then we have a couple others for dealing
02:53:04.560 with JSON. So we have JSON Assert and JSON Path. Whenever you're trying to test Assert against
02:53:12.320 particular sets of JSON data, these two libraries are very helpful. And then we have Awadability,
02:53:19.360 a library for testing asynchronous systems. So it's good just to know what's in there. These
02:53:25.360 links in here are all links to the documentation on the various libraries. You don't need to study
02:53:31.200 them and become experts on them. But I would dig through there and just get a really good overview
02:53:36.720 of what they are and what some of the code looks like. That way, again, when you see a code example
02:53:43.120 online or somebody shows you some tests, you can quickly scan it and understand what libraries are
02:53:48.800 being used to kind of build out those tests. Okay, so that's enough of an overview. Let's go through
02:53:54.480 and start writing some tests for some of the code that we've written so far. All right, so the first
02:53:58.880 thing I want to look at is getting this context loads test to work. Again, if you just download
02:54:03.600 a project, this is going to run right away. But we're running into an issue here. And I want to
02:54:07.920 talk about that issue. So we are using a database. That database is because we are using this
02:54:14.320 compose.yaml, right? When a Spring Boot application starts, it will see that file,
02:54:19.520 it will run Docker compose up, and that is in that connection gets created and put into the
02:54:25.440 environment at runtime. We're not running an application. We're running a test. So it's a
02:54:31.280 little bit different of a workflow. So we don't have a database up and running. So in the test
02:54:37.120 scenario, I would have to come in here and actually run Docker compose up so that that database starts
02:54:45.200 up. See it start in a second. And that is up and running. And now that that's up and running,
02:54:51.680 I have to come in here and actually set a data source because again, it's not getting injected
02:54:56.720 from the Docker compose file because that's not getting run in a test scenario. So now that I
02:55:03.040 have this up and running, I should be able to run my application tests. And that should work. Now,
02:55:11.440 in a real world, I would not do this. This is not my workflow. In the real world,
02:55:16.000 I would use something called test containers. If you haven't heard about test containers yet,
02:55:21.040 it's a really great project. Go ahead and check out testcontainers.org.
02:55:26.160 You can go ahead and check out the docs to learn more. There's different languages support,
02:55:30.880 but the Java support is really great, has a bunch of really great features.
02:55:35.360 And really, it just allows you to say, Hey, I want to the same way that we used a container
02:55:40.320 for development, we could use a container for testing. And I like this approach much better.
02:55:45.280 We used to maybe use something like an in memory database, like an H2 database for testing.
02:55:51.440 But then we have an H2 database and testing a Postgres database in production. And we're really
02:55:57.360 not aligned, right? Like we want to be as close to production as we as we can get on our local
02:56:03.040 development machines. So in that sense, I like using test containers for tests. But to keep this
02:56:09.920 short, I think we'll just leave that at that. For now, I have some more videos on my YouTube
02:56:15.280 channel, if you're interested in learning more about test containers. But we'll just leave that
02:56:19.200 as it is for now. So I want to focus in on some other tests. And to do that, let's go ahead and
02:56:26.560 close this out. I have brought in our in memory run repository. I think we overrode that here while
02:56:35.360 we were going through stuff. But if you want to grab it from the repository, it's there we've we
02:56:39.600 went through this, right? This is just using an in memory collection. So I want to talk about
02:56:44.560 how to test this. So the first thing I'm going to do is go ahead and generate a test for this,
02:56:50.160 I can say create test. And this will actually create the right package and the name of the
02:56:54.960 test for us. Now JUnit is looking for tests that end in the word test or tests. So that's why it
02:57:01.200 gives us this nice class name, it says in memory run repository test. Yes, this is great. So I'm
02:57:07.840 going to click OK. And now we're dropped into this test. And you'll see this test is now in
02:57:15.440 the right package down here. Cool. So now we can begin to write our tests. Now we aren't going to
02:57:22.720 use any annotations on this, we aren't going to do any kind of special things with the spring
02:57:28.720 environment. Because in this case, we just have a class that holds some data in a data structure,
02:57:36.880 a list to be specific. And we don't need to involve spring in this. This is for me a true
02:57:42.560 unit test, right? Because all we care about is the in memory repository. We'll call this
02:57:48.880 in memory repository, although that's kind of long, let's make it easier. So now I have a repository.
02:57:56.080 Now if that repository gets created, we can let's do actually let's think about this for one second.
02:58:05.440 So I'm going to in JUnit, there are some special methods that we can use. So we can basically say,
02:58:12.960 hey, before each, I want you to go ahead and do some setup in my application. So I'll call this
02:58:18.160 setup. And oh, that's pretty good. Let me just I think I need a null here. And a null here.
02:58:29.360 Right. Right. So that looks pretty good. So all we're doing is creating an instance of this
02:58:40.560 repository. Now the reason we are setting up two runs is if we go into the in memory repository,
02:58:47.840 we have a create method. And this method is actually going to get called by the lifecycle
02:58:56.880 in spring. So this app post construct gets called, and these get created. In this case,
02:59:02.240 we are not involving spring. So that that init method is never going to get called. And we want
02:59:07.440 to have a couple of runs in the collection to be able to test against. So now we can write a simple
02:59:14.320 test, we can say at test. And we can say avoid should find, find all runs. And yeah, that's a
02:59:25.280 pretty good assertion there. So all we're doing here is and actually, let me let me let me let me
02:59:32.240 get this out of here. Let's do this. Let's say hey, repository find all oops, find all and give me
02:59:40.800 a variable for that. And we'll call this runs. And then let's just do this, just so we can be a
02:59:48.960 little bit more clear what's going on here. Right. So what we're doing is we have an instance of the
02:59:58.880 repository, we've created two new runs in there. We're saying, hey, if we call the find all method,
03:00:05.520 basically, we're expecting two runs to come back, we know that there's two runs in there.
03:00:10.160 We know that there's two that are going to come back. There is a third argument here. And you
03:00:15.360 can basically give a message on what should have happened. So in this case, we could say should
03:00:23.600 have returned two runs, right. So now we can go in and we can go ahead and run our test here.
03:00:31.280 And we see that it's green. And green is good. Now, you also hear of like TDD styles. So I come in,
03:00:39.520 I would write this method first, and then I would make it fail. And then I would go into
03:00:44.880 the in memory repository and write this method. So a lot of the questions that come up around
03:00:50.560 testing are like, what should I test? Well, like, what are you writing? What what classes are you
03:00:54.960 writing? In this case, we're writing this in memory run repository. This is our code that deals with
03:01:00.320 a collection of state. So yeah, we should be writing tests against this. In this case, we don't need
03:01:05.760 some integration tests. We're just testing this class, right. So that's one test. We're gonna,
03:01:13.520 we're gonna kind of copy paste a lot of this, I don't want to walk through every single method
03:01:17.520 and every single test. And actually, these are gonna fail because we need nulls here. And again,
03:01:24.160 this is just because I wrote these before the database stuff went in. Remember, we added that
03:01:30.000 null. So we have some tests here should find runs with a valid ID should not find a run with an
03:01:36.560 invalid ID. So it should throw some exception should create new run, although I don't know if
03:01:43.920 that's gonna throw an exception. Maybe we'll check it. So I just have a bunch of tests in here. And we
03:01:50.640 can run each of them individually, or you can run them as kind of a suite right here. And then we
03:01:56.560 got greens for all of those. So those are good. Okay, so that's our first test are in mom in
03:02:02.560 memory run repository. What should we test next? Alright, the next test we're gonna write has to
03:02:09.040 do with the JDBC run repository. So I'm going to go ahead and create a test for that. Now this is
03:02:16.320 going to be a little bit different, we are not creating a unit test, we have to deal with some
03:02:20.000 of the infrastructure in spring. And we also have to like talk to a database, right? We're like,
03:02:24.240 we're testing out this run repository. So to bring in the test support with spring, we could use that
03:02:30.480 at spring boot test annotation that we saw before. But one thing I want to kind of talk about with
03:02:36.000 that is, at first, your test might be very fast. But as your application grows in size, that might
03:02:43.520 tend to slow the test down. And that is because that at spring boot test annotation is basically
03:02:48.960 going to load the entire application context. That means all the classes in your system that
03:02:54.560 you might need, it's going to go ahead and load those. But for this class, this test, the JDBC
03:03:00.800 run repository does I don't really care about all of the classes in the system, really only the
03:03:06.480 classes that were that that pertain to a JDBC test. And so there are these things called slice
03:03:13.120 tests in spring. And that says, hey, this is the slice that we're testing now only load all of the
03:03:19.520 things that are equivalent to that. So there are a bunch of this, one of these is at JDBC tests.
03:03:26.160 So if we go into at JDBC test, and look at the documentation, we can see that, hey, this is an
03:03:32.800 annotation for JDBC tests that only focus on JDBC based components. This means that it's going to
03:03:40.000 disable full auto configuration, and instead only configuration relevant to JDB, JDBC tests.
03:03:48.640 By default, JDBC tests are transactional, and roll back at the end of each test. That's good
03:03:55.360 to know, right? Like if you add a new one, and then you move to the next test, that new one is
03:03:59.600 no longer there. This also gives us an embedded in memory database, replacing any explicit or
03:04:08.160 usually auto configured data sources. This is important. We're okay, we could be okay with
03:04:13.840 using an in memory database. But what if you wanted to say don't do that, just use the one that I have.
03:04:20.880 So we need to understand how to do that. So this is the at JDBC test annotation.
03:04:27.680 Now, I want to use that repository, I want to say at auto wired, give me an instance of the JDBC
03:04:35.920 run repository, right? So we'll see in a second. I don't believe that'll work. But we'll check that
03:04:43.040 in a second. And I know we talked about this earlier, when it comes to dependency injection,
03:04:48.560 we want to favor constructor based dependency injection, that really is in our own code in a
03:04:54.480 test. I don't think that makes a big difference, because we aren't trying to test a test. So using
03:04:59.840 reflection here is okay in my books. So we have a JDBC test, we're going to I'm actually going to
03:05:09.200 just paste some code in here. So we can kind of take a look at this. Again, we're going to use
03:05:14.160 a setup method. And this is going to, we're gonna have to fix these. So no, so I promise you all of
03:05:24.320 these worked at once. But that was before I introduced the spring data component. So now
03:05:30.160 you know, we're using spring data now. So the entity uses an ID on there. And actually,
03:05:39.760 I think I may get rid of that for these tests. So let's do that.
03:05:47.440 So let's go back into run and say that we're not using this right now.
03:05:54.320 And then in my schema, I'll kind of remove this. Again, this isn't something you'll have to deal
03:06:03.280 with. This is just me having to like, show a bunch of different layers of abstraction. And you won't
03:06:10.560 have to deal with that. So okay, so let's see, we have a JDBC run repository tests, no errors.
03:06:20.080 So all we're doing here is we're calling our repository, and we're creating some.
03:06:26.720 And then we want to be able to like find all find by ID, the same things that we did in the
03:06:30.880 in memory one, but this time, we're doing against the database. Now, again, which database are we
03:06:36.160 doing it against? If we don't do anything, we'll be doing it against an in memory database. So
03:06:41.920 let's see. Let's just I'm curious if see if that works. Let's go ahead and run that.
03:06:46.400 Yeah, I didn't think so. These things are gonna start to complain still.
03:07:00.000 And don't worry, those ones will still work now. So
03:07:04.720 let's try and run that again. Oh, we have more, more, more.
03:07:16.400 Alright, and we have some failures, but that's okay. That's probably not test failures. Let's
03:07:34.560 dig into here. And yeah, so failed to replace data source within embedded database for tests,
03:07:42.480 we already have a database up and running, right? So how can we fix that? Again, we don't want to
03:07:47.200 use that in memory database, we want to say, hey, we already have one up and running, and we have
03:07:52.320 one configured. So I can just say auto configure test database. And we're just going to say replace
03:08:01.120 none. We don't we don't want we don't want you to replace it with a embedded one. So now if we go
03:08:06.000 ahead and run this, we should be using the regular database. And we're still having an issue.
03:08:14.080 I suspect it has something to do with us flip flopping back and forth between all of the different
03:08:18.880 examples that we're using. But nonetheless, let's see if we can't debug this in real time.
03:08:26.480 No qualifying mean of type JDBC run repository is available. So this is a good thing. This is
03:08:33.680 basically telling us that hey, this run repository that you've tried to auto wire into this test
03:08:39.200 doesn't exist. Why doesn't exist? This app JDBC tests only loads certain things in certain auto
03:08:46.880 configurations. So if it's one of those classes that we want that we don't have available to us,
03:08:53.280 we need to just go ahead and import it and JDBC run repository. Let's see if that works.
03:08:59.120 All right, still some red. Yeah, I believe this has to do with
03:09:12.800 that already exists. So again, we're getting into a scenario where we're just hitting this because
03:09:19.200 of all the fun testing I'm doing. So let's just do this drop table if exists run. And then let's
03:09:30.800 try and run that again. So this is just basically create every time. And there we go. So again,
03:09:37.200 I think in the real world, we are I'm using something like test containers. I'm trying to
03:09:41.760 avoid that because I don't want to throw something else at you. But these things that we're running
03:09:48.000 into are all because of the demo stuff that we're doing. So that is our JDBC run repository test.
03:09:54.640 We've now been able to write tests against two of those classes that we wrote early on.
03:09:59.680 I think the next thing that we really want to test is the run controller. And we want to test
03:10:04.800 this from two different angles, we want to write more of a unit test that just tests the controller,
03:10:09.680 the inputs and the outputs. And then we want to test an integration of this, we want to say, Hey,
03:10:15.600 if I run a test against this run controller that calls the repository, I want to make sure that
03:10:22.320 works as well. So I think those are really those are the two tests left there. And then we'll write
03:10:27.840 a test against the user client that we wrote earlier. Alright, so we're going to write a couple
03:10:33.040 tests here for a run controller, we're going to create a new test, we'll call this the run
03:10:36.880 controller test that looks good. This is also going to be a slice test, we are just testing
03:10:43.040 the web, the web slice. So I can say this is a web MVC test. And we're specifically testing the
03:10:52.000 run controller. So I'm going to set up a couple of things in here. And then we'll go ahead and write
03:10:57.120 a test. So at auto wired, because this is a web MVC test, it will auto configure Mach MVC auto
03:11:05.200 configure MVC auto configure cache, always drill down into some of these annotations. And you'll
03:11:11.680 find out that they are really just annotations that are annotated with other annotations.
03:11:16.640 But you can drill into these to kind of figure out what those are. But one of the things that
03:11:20.400 it does is it gives us a Mach MVC. And this Mach MVC is the main entry point for server side spring
03:11:29.200 MVC test support. So we can create a Mach MVC, then we can perform actions against it in a Mach
03:11:36.320 environment. We could say, hey, I want to perform a get to slash form. And here's what I expect to
03:11:41.840 happen. So this is really helpful in testing the input and the output of a controller. Also, I'm
03:11:49.520 going to auto wire in the object mapper. We saw this earlier when we were dealing with JSON.
03:11:55.280 This is from the Jackson library that comes in with the web support. And it allows us to basically
03:12:01.840 convert things from JSON to a type or from a type to JSON. Here's where the fun begins. Now,
03:12:09.600 remember, the controller is dependent on this thing called the run repository.
03:12:15.440 That run repository talks to a database in a unit controller style test. We don't want to we don't
03:12:22.160 care about outside dependencies, whether it talks to a database talks to a service, we don't care
03:12:26.880 about that. So this is where constructor, constructor injection comes into play is we can
03:12:32.160 mock this dependency, we can say, hey, provide me with a Mach being which is not a real one,
03:12:39.200 it's just an in place one. So this is really nice. So we're saying mock this particular thing
03:12:46.000 when you're setting up this run controller. Finally, because we're not talking to a database,
03:12:51.920 we don't have any runs. So we're going to set those up here. So how how do we write a test
03:13:00.160 that uses a mock? So first, we're going to start with a test. We're going to say void should find
03:13:11.200 if I could spell right, find all runs, right? Come on, Dan. All right. So now what we want to do is
03:13:20.240 we want to mock out this repository, we want to say we want to say when so this is coming from
03:13:30.000 Makito. So why that did that. So when the repositories find method is called find all
03:13:42.320 method is called, then return this list of runs that I've created, right? And so again, we're going
03:13:48.720 to import that from Makito. So now we're going to use the mock MVC framework here to say perform a
03:13:55.280 get request. So where does this get request come from? I don't know why I can't find this. This
03:14:02.400 should come from mock MVC request builders that get. Yeah, so you can import that as static if you
03:14:10.640 want, you should add exception for that. So we're performing a get request against slash API slash
03:14:18.000 runs. And then what we expect is the status to be OK. And here's where we're using that JSON
03:14:25.200 path. Remember all those libraries I said that get kind of brought in for us. So we're saying,
03:14:31.600 hey, from a result mattress standpoint, what is the JSON path? And so let's bring in size.
03:14:42.800 So basically, we're saying, hey, this is an expression you can say, hey, like from the
03:14:47.360 root, give me the size. We know that it's going to be 1. And we want to make sure that it's equal
03:14:52.240 to the size of the runs, which in this case is 1. So with all that in place, let's see if that
03:14:58.720 works and it doesn't. That's OK. We like seeing red first, then we can figure out what's going on.
03:15:04.640 So hey, the run repository is not available. Yeah, that would make sense. So run controller,
03:15:14.240 we want to mock out the, I guess we're mocking out the wrong thing here.
03:15:20.160 So let's mock out the run repository. And let's see if that works now.
03:15:31.120 OK, cool. So we got one of our methods running, which is finding all the runs.
03:15:36.800 Now, again, I'm just going to copy some copy and paste some code in here.
03:15:41.520 So we don't have to watch me write this. But now what we can do is we can say, hey, I should find
03:15:48.640 one run. Here's the run I'm expecting when the find by ID method is called.
03:15:57.760 And you match any integer, then go ahead and return this. I want to return an optional run,
03:16:04.480 optional dot of, and then here's the run. So now try to go get one run and expect that the status
03:16:11.360 is OK and expect the data that we're getting back is this. Again, we're checking the input,
03:16:17.200 so we're passing some path in here, and then we're checking what we get back.
03:16:22.560 Part of what we're getting back in the response is, hey, is it a 200? Is it a 400? Is it a 404?
03:16:29.040 If it is a 200, what is the data? So those are the things that we're checking
03:16:33.280 in more of a controller unit test. We're not testing the whole flow yet.
03:16:38.560 And then we're testing, hey, what happens if you return an invalid one? What happens if you create
03:16:44.880 a new run or delete it or an update? So if we go ahead and test this out, and I believe that
03:16:53.040 this may fail because we've switched over to this run repository.
03:16:57.440 Again, too many moving parts, but let's see if we can't fix it. It's fun fixing things. So let's see.
03:17:02.880 I believe this is saying delete API slash runs and expect status is no content. What is it?
03:17:18.480 No value present. That's because I believe the delete should take the actual run.
03:17:27.680 So we say API slash run slash run slash delete and content type is application slash JSON
03:17:40.960 content type. And then the content is the actual run. So sure, that looks good. And then
03:17:56.960 do we get one too many there?
03:18:03.360 All right. So now, let's see.
03:18:08.240 Let's go ahead and run this one. Actually, let's just run them all again.
03:18:18.880 No value present. OK, I'm going to skip this for now. I have this updated in the final repository.
03:18:25.200 So these are our unit tests more because we're not we're not including the outside dependencies.
03:18:31.680 But what if we wanted to write more of an integration test? I want to see the flow
03:18:36.640 when we go ahead and do something. And it talks to the database talks to the repository, which
03:18:43.040 talks to the database. How can we get that to work? So I'm going to create another test here.
03:18:48.640 But this time, I'm going to call this our run controller int test for integration because
03:18:54.640 we're integrating other services, other libraries. And so this is more of a full end to end test.
03:19:02.640 All right. So now we're writing the integration test for the controller. I'm actually probably
03:19:06.880 just going to write one method here for this one. But I'll try and get the final repo updated with
03:19:13.120 everything. So we're going to use at Spring Boot test annotation. Now, we're also going to set up
03:19:19.680 a web environment. You see the code assistance already there kind of helping me out. We're
03:19:24.160 setting up a web environment to say, I want to run a server, but I want you to run it on a random
03:19:30.160 port because this is a test. I really don't care what port it's on as a test. But when we do that,
03:19:36.800 we will need to know what port it's running on. And to do so, we can use the local server port
03:19:42.640 annotation and then just provide a variable for that. So now we have the server port. Now we can
03:19:49.920 set up a before each. And we can basically say, let's go ahead and set up a REST client. So we're
03:19:57.520 going to use a REST client here. We've seen the REST client already. And we'll say REST client.
03:20:03.120 And we'll say REST client is equal to, remember, there are some of those static factory methods,
03:20:09.920 one of which is create. Oh, that looks pretty good. Thank you. And we're saying, hey,
03:20:15.440 go ahead and set up the base URL as HTTP localhost, not 8080, but whatever that random server port
03:20:23.200 is, right? So with that in place, we should be able to say at test. And I want to, again, should
03:20:34.080 find all runs. And what I want to do is I want to use the REST client to actually make a call.
03:20:47.920 So I want to say REST clients.get to the URI of API slash runs. So now that that's there, again,
03:21:00.000 we'll just retrieve that. We'll turn that into a body of new parameterized typed reference.
03:21:07.360 And then from that, actually, from that, I'll get a list of, whoops.
03:21:17.200 From that, I'll get a list of runs. And I don't know why it's saying object. I don't want an object.
03:21:23.680 I want a list of runs, right? So now that I have a list of runs, I can say, let's assert equals.
03:21:40.000 And we should have 10 runs because we know 10 runs are in the database. Let's see if that works.
03:21:46.160 So now we're actually performing an integration test where we make a call into the controller,
03:21:51.680 it talks to the repository that talks to the database, finds all of our runs, and then asserts
03:21:56.800 that that's equals. So again, we've written some other tests similar to this. Again, I would just
03:22:04.320 do this for find by ID, post, put, delete, and call it a day. All right. So one last test I want to
03:22:10.880 write here is for the user REST client. So let's go ahead and create a test for that. Now, we are
03:22:18.000 not going to write this. I'm just going to kind of show you this one. But let's talk through this.
03:22:23.840 So there is a annotation called the REST client test. And what this does is it's an annotation
03:22:31.840 for Spring REST client that focuses only on the beings that use the REST template builder or the
03:22:38.000 REST client app builder. So this is, again, going to disable full auto configuration. And really,
03:22:44.480 all we want is the relevant stuff to a REST client test like Jackson or Gson or some auto
03:22:51.120 configuration for JSON components, but not regular component beans. So not all the beans are going to
03:22:56.560 get loaded. So if you find something you need in there, you'll have to import that. So what we also
03:23:02.880 get from that, if you look at this, there's a auto configure mock REST service server. So we get
03:23:10.000 this mock server. So we can use a server to make a call out. Then we get the REST client we want
03:23:16.960 auto wear it in and then the object mapper, which we've talked about before. So now we have a test
03:23:22.960 here. And we're using the given when then kind of set up. And we're saying given here's one particular
03:23:28.880 user I have. And I don't know, new geo lat long. Why is this complaining? Oh, this wants a double.
03:23:46.400 Oh, we set these up as strings for some reason. Okay. Those should be doubles. I think they're
03:23:54.320 doubles in the final. So we'll fix that. Okay. So we have our user. And then we say here's our list
03:24:04.720 of users. It really is just one. So now we can use the server to say, I expect a request to,
03:24:12.560 and in this case, the JSON placeholder service slash users. So we're not actually calling out
03:24:18.720 to the server this public URL. But we're kind of mocking that out. And we're saying, hey,
03:24:25.840 I want you to respond with a success. And here's the media type. So let's go ahead and actually
03:24:31.280 perform that. Go ahead and call the client dot find all. And I expect the users to equal this.
03:24:36.880 So we're kind of mocking that out. And this is a way that we can mock those REST client calls out.
03:24:42.480 So if we're performing a full integration test, we don't need to mock that. But this is a nice
03:24:48.000 infrastructure to kind of test those out. So let's see if this works. And it doesn't. Yeah,
03:24:57.760 this is because double can't be converted to a string. Is this same thing? Was I running all of
03:25:10.560 those? Again, I think in the final code, this is a double. So let's just try and run this one.
03:25:23.760 And there we go. And let's try and run them all. If they pass, we'll kind of look through them
03:25:28.560 real quickly. That one doesn't. Yeah, okay, that's just the expectation. So there was the one. And
03:25:37.600 then this is to find by single one. So we do that same request. But now we're doing it to slash users
03:25:43.520 slash one, we're saying, hey, respond with a success. And here's what I basically wanted you to
03:25:49.520 write this value as a string. So write the JSON. Now I can go ahead and do this, I can do a bunch
03:25:55.520 of assertions here, I'm saying, hey, make sure the name is this, the username is this, and the
03:25:59.920 email is this, and then all I can use is assert all to make sure everything in the address is
03:26:06.320 what it's supposed to be. Again, double versus string. So if we run this again, so pass,
03:26:13.840 then we're saying, hey, phone, website, and company, I want to assert all of those. So let's
03:26:19.440 go ahead and just run that again to make sure that works. And it didn't.
03:26:25.520 Maybe we had these backwards.
03:26:38.000 Let's see, lat is 37, huh?
03:26:46.080 Okay, we'll rerun these. Hopefully third time's a charm, and it is. Great. So those are the tests.
03:26:54.720 Now I know we didn't kind of spend a whole ton of time on these, but I just wanted to give you
03:26:59.680 the infrastructure, like what is included in writing tests and what are the pieces that I
03:27:04.480 need to understand. You can easily go back through the repository later and actually dig through
03:27:09.920 every line of code if you want to here. But I think just getting an overview of kind of what
03:27:14.720 tests you can write, what are some of the annotations that you'll use, what are some
03:27:18.480 of the libraries included that I'll give you. But again, I would try to stick to once you get
03:27:24.160 the mechanics down. I mean, you're just learning now. If you're just learning Spring Boot,
03:27:28.000 you know, build stuff first. But once you get the mechanics down, try to make it a focus of,
03:27:33.280 okay, I just wrote this controller. What kind of test can I write for it? Or even better,
03:27:39.760 before you write the controller, start writing the tests for it. And this will just through
03:27:45.440 repetition and writing these different types of tests, you'll be writing all kinds of tests in
03:27:51.360 no time. So with that, I hope you learned something. I hope you enjoyed this section on
03:27:56.160 testing. I think that is close to the end of this course. I can't believe it. Let's say a few words
03:28:03.680 and wrap this thing up. Wow. Congratulations for making it all the way through this course. I hope
03:28:09.520 you had a lot of fun. I hope you learned something new in this course. I had a lot of fun putting
03:28:14.560 this together. So I hope that shows through the videos that we made here today. Again, I want to
03:28:21.520 double back and say thank you to free code camp for having me. Thank you to all of you
03:28:26.640 for watching this. I have the GitHub repository here. This is going to be a kind of ever living
03:28:33.200 document. This is a way for us to stay in touch. So I'll keep updating this as the needs come in,
03:28:38.960 as issues come in. If you have issues with some of this code or questions, I'll open up discussions
03:28:44.000 on this GitHub repo. I also have a list of resources. I'm going to put some more resources
03:28:49.520 in here. I have things like books and other courses you may want to take. But for now,
03:28:55.120 the resources in there are me. So I have a website, a YouTube channel. Again, if you want to keep
03:28:59.680 diving into some of the spring stuff, a Twitter account. Also on the spring side, Spring Academy,
03:29:05.360 I just launched one of my first free courses, my free guides on there. Actually, there's going to
03:29:10.880 be two on there now. So free guide on 3.2. Like a lot of the stuff that we talked about today when
03:29:16.560 it comes to the JDBC client, the REST client, virtual threads, that will be included on Spring
03:29:21.920 Academy. So that's a free resource. Go ahead and check that out. The Spring Developer channel,
03:29:27.040 this is a really great YouTube channel with a whole bunch of spring content.
03:29:31.840 Check out the spring IO website, the spring blog if you want to stay up to date with everything in
03:29:36.000 the ecosystem. And Spring Office hours, that's the podcast that I am a host of. And part of that
03:29:42.240 is keeping you up to date with everything that's going on in the ecosystem, as well as answering
03:29:47.360 your questions. So if you have a question about something you went here through on this course,
03:29:52.160 join us every Monday, 1pm Eastern may change in the future. Who knows? You can always check out
03:29:57.360 spring office hours.io to find out more about that. But please come there with your questions.
03:30:02.800 Tell me you went through this course. That'd be awesome to hear. And with that, those are my
03:30:08.160 resources. I'll update that. Again, I'm honored to have been your teacher in this course.
03:30:13.840 Very thankful to Free Code Camp for hosting me. Very thankful for to my employer Broadcom and
03:30:20.560 the spring team for letting me do this. It was a lot of fun. And I can't wait for you to get your
03:30:26.400 hands on this course. I know I'm saying that as you're probably watching this, but I'm saying this
03:30:31.920 after recording this and ready to get this into the hands of you guys. This was a lot of fun.
03:30:36.560 I appreciate it. And as always, friends, happy coding.
